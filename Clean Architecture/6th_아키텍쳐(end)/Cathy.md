> 시스템의 아키텍처는 _의존성 규칙을 준수_ 하며, _고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계_ 에 의해 정의된다.
^^^ 반복되는 아키텍처 정의

# 26장 메인 컴포넌트
메인 컴포넌트는 시스템의 나머지 컴포넌트를 생성, 조정,관리하는 컴포넌트이다.
이는 궁극적인 세부사항으로 가장 낮은 수준의 정책이다. 
아키텍쳐 계층 가장 바깥쪽에 위치하여, 고수준의 시스템을 위한 모든것을 로드한 후 제어권을 고수준의 시스템(엔티티)에게 전달한다.

메인 컴포넌트는 초기 설정을 구성하고 외부 자원 수집 및 제어권을 고수준 정책으로 넘기는 _어플리케이션의 플러그인_ 이라고 생각하면한다.
플러그인이므로 애플리케이션별 설정이 다르도록하여 둘 이상의 메인 컴포넌트를 만들 수 있다.

> theme, lang 적용, config 값에 다른 다른 렌더링 정도로 생각하면 되겠다

# 27장 크고 작은 모든 서비스들

서비스 지향의 마이크로서비스 아키텍처 (AWS, GCP) 같은 것은 시스템 확정성과 개발 가능성 측면에서 유용하지만,
이 들을 자세히 보면, 의존성 규칙을 따르며 경계를 넘나드는 _함수호출_ 이다. 
아키텍처적으로 그리 중요한 요소는 아니다. 

서비스 아키텍처는 다음과 같은 이점을 가진다고 하지만,
- 서비스가 항상 독립적으로 개발, 배포, 운영할 수 있는 것
- 시스템을 독립적으로 개발하고 배포 가능한, n개의 서비스들을 이용하여 만들 수 있으며, 개발 및 배포 독립성으로 확장 가능함
따지고 보면 오류들이 있다. 

서비스 아키텍처의 오류들 
(결합 분리의 오류)서비스들은 데이터 레코드에 강하게 결합되어 서비스들 간에 간접적인 결합이 생긴다.
  - 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면 이 필드를 사용하는 서비스는 모두 변경되어야함.
(개발 및 배포 독립성의 오류) 서비스가 항상 독립적으로 개발, 배포, 운영할 수 있는 것이 아니다.
  - 이 독립성은 다른 아키텍처도 가지는 이점이다


위 오류들은 어떻게 해결을 하는가? 컴포넌트 기반 아키텍쳐
  -> SOLID 원칙으로 설계한 컴포넌트 구조를 갖추어 오류들을 해결 할 수 있다.
  -> 서비스 내부의 의존성 규칙을 준수하는 컴포넌트 아키텍처로 설계한다.

> 저자가 컴포넌트 기반 아키텍처를 찬양하는 듯 하다.
> Monolithic vs SOA vs Microservice 구분 할 수 있지만 이것들을 저자는 통틀어서 서비스 지향이라고 구분하여 설명한 것 같다.

[Monolithic vs SOA vs Microservice, 다양한 아키텍처와의 비교](https://wonit.tistory.com/487)

# 28장 테스트 경계
테스트는 시스템의 일부이며, 아키텍처에도 관여한다.
아주작은 테스트이든, TDD이든 대규모이든 아키텍처적으로는 관점으로는 모두 동일하게 본다.

테스트는
- 태생적으로 의존성 규칙을 따른다.
  가장 바깥 계층에서 안으로 향한다.
- 독립적으로 배포 가능하다
- 시스템 컴포넌트 중 가장 고립되어 있다.
  운영에 꼭 필요하지 않다. 테스트에 의존하지 않는다.

테스트를 고려할 때는 변동성이 큰 GUI를 의존하지 않고 업무규칙을 의존하여 테스트할 수 있도록 설계해야한다.
뿐만 아니라, 테스트 구조를 어플리케이션 구조로 분리한다 -> 테스트 API

테스트는 시스템의 일부이다. 따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻으려면 테스트를 잘 설계해야 한다.
-> 테스트는 유지보수에 용이하게 잘 설계해야 한다.
