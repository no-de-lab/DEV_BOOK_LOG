야키텍처: 시스템의 생명 주기를 지원

# 아키텍처의 역할
1. 쉽게 시스템을 개발할 수 있도록 만들어야한다.
2. 한번에 쉽게 배포하도록 해야한다.
3. 운영에 필요한 요구를 알려준다. 시스템이 가진 의도를 아키텍처 수준에서 알아볼 수 있게해야한다. 
4. 유지보수 비용을 크게 줄인다. 컴포넌트 분리 및 안정된 인터페이스를 둚으로 탐사 비용 줄인다. 
5. 중요한 것은, 선택사항을 가능한 많이 두어야한다.
6. 하드웨어 장치와도 분리해야한다. 
7. 세부사항에 대한 결정을 최대한 미루는 방식으로 아키텍트를 설계해야한다.

# 중요한 개념 -> 결합 분리: 계층과 유스케이스의 결합을 분리하는 것.
1. 소스 수준
2. 배포 수준
3. 서비스 수준

> 중요한 것은 언제든 좋은 아키텍처를 위해 원래 형태로 돌아갈 수 있어야한다는 것.

# 아키텍처는 선을 그어야한다.
관련이 있는 것과 없는 것 사이의 선을 긋는다. 
단일 책임 원칙으로, 어디에 선을 그어야할지 파악한다.


# 경계를 횡단하기
만들어놓은 경계를 횡단하는 것: 소스 코드 의존성 관리를 함으로 가능

가장 단순하고 흔한 경계는 물리적으로 엄격히 구분되지 않는 형태이다. (구분되는 단순한 형태는 동적 링크 라이브러리)
- 배포 관점에서는 단일체는 경계가 드러나지 않는다. 
- 단일체 > 배포형 컴포넌트 > 로컬 프로세스 > 서비스 순으로 물리적 경계가 강해진다.

# 아키텍처
모든 시스템 아키텍처에 대한 아이디어는 하나의 목표를 말한다.: 관심사의 분리
모두 소프트웨어를 계층으로 분리하여 관심사의 분리라는 목표를 달성할 수 있다. 
프레임워크/테스트/UI/DB/외부 에이전시

### 의존성 규칙
클린 아키텍처를 이루는 엔티티/유스케이스/컨트롤러, 게이트웨이 등/외부 인터페이스는 안에서부터 동심원을 이룬다.
안에 있는 것이(엔티티) 고수준의 소프트웨어다. 내부는 외부에 대하여 아무것도 알지 못한다.

- 엔티티: 전사적 핵심 업무 규칙을 캡슐화한다.
- 유스케이스: 애플리케이션에 특화된 업무 규칙을 포함한다. 
- 인터페이스 어댑터: 데이터를 내외로 편리하게 바꾼다.
-프레임워크와 드라이버: 모든 세부사항이 위치하는 곳

원의 개수는 달라질 수 있지만, 의존성 규칙은 지켜야한다. 
- 그러나, 의존성 규칙이 달라져야할 경우, 의존성 역전 원칙을 사용하여 해결해야한다. 
그 상황이 발생할 때, 데이터 구조는 가장 간단한 데이터 구조로 이뤄져있다. 

# 프레젠터와 험블객체
### 험블객체란
디자인 패턴, 테스트하기 어려운 행위와 쉬운 행위를 분리가 쉽게 고안.
애플리케이션 > 프레젠터에 객체 전달>프래젠터 포맷팅 문자열 고안 > 뷰모델이라는 데이터 구조에 담음 > 뷰는 뷰 모델에서 이를 찾음.

그외에 뷰가 맡은 역할은 없어서, 뷰는 humble 객체다. 

데이터베이스와 유스케이스 인터랙처 사이에서, 데이터베이스 구현체는 험블 객체다. ORM은 게이트웨이 인터페이스와 데이터베이스사이에서 또 다른 험블객체 경계를 형성한다. 

결국, 각 아키텍처 경계마다 험블 객체를 발견 가능하고, 험블 객체 패턴을 이용해 전체 시스템의 테스트 용이성을 높인다.

# 부분적 경계
그러나 경계를 만드는 데는 비용이 많이든다. 
그래서 부분적 경계를 생성하는 방법을 제시한다.


- 마지막 단계 건너뛰기
독립적으로 컴파일하고 배포할 수 있는 컴포넌트 작업 모두 수행 후, 단일 컴포넌트에 모아만 두는 것이다.
버전 번호도 없고, 배포 관리 부담도 없다.
- 일차원 경계
양방향으로 격리된 상태를 유지해야하는 완벽한 아키텍처와는 달리, 한쪽만 있다. 
이 경우 비밀 통로가 생길 수 있다. (클라이언트와 Impl사이)
- 퍼사드 패턴
경계는 퍼사드 클래스로만 간단히 정의하고, 클라이언트는 퍼사드로만 호출한다. 
하지만 이 경우 소스 코드가 변경되면 클라이언트도 무조건 재컴파일해야한다는 단점이있다.


# 계층과 경계

아키텍처 경계는 어디에나 존재한다. 어디에 경계를 두어야하고 부분적으로 구현할 곳이 어디고 무시할 곳이 어딘지 우선순위가 필요하다.
프로제그 초반에는 좀 지켜보고, 조짐을 파악하고 비용을 가늠한 뒤 검토한다. 
