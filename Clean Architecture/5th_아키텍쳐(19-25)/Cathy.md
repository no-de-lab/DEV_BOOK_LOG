# 19장 정책과 수준
- 정책
소프트웨어 시스템이란? 정책을 기술 한 것이다
컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서라고 말할 수 있다. 
하나의 정책은 여러개의 정책으로 쪼갤 수 있다.
소프트웨어 아키텍처르 개발하는 기술에는 정책을 신중하게 분리, 재편성하는 일도 포함한다.
같은 이유와 같은 시점에 변경되는 정책은 같은 수준에 위치하며, 같은 컴포 컴포넌트에 속해야 한다.

- 수준
  - 수준을 엄밀하게 정의하자면 입력과 출력까지의 거리다.
    (???)시스템의 입출력과 멀리 위치할수록 정책의 수준은 높아진다.

  - 데이터 흐름과 소스 코드의 의존성은 향상 같은 방향을 가리키지 않는다. 
  - 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안된다.
  - 정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다
    고수준 정책: 출력에서 부터 멀리 떨어진 정책으로 중요한 이유로 변경을 하며, 변화가 빈번하지 않다.
    저수준 정책: 입출력과 가까이 위치한 정책으로 덜 중요한 이유로 변경하며, 변화가 빈번하다.
  - 모든 소스코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다.
    (실제 코드에서 어떻게 정리를 할 수 있을까?)
  _저수준 컴포넌트가 고수준 컴포넌트에 플러그인_

# 20장 업무규칙
어플리케이션을 업무규칙과 플러그인으로 구분하려면 _업무규칙을 정확히 이해_ 해야한다
업무규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야한다. -> _핵심 업무 규칙_ 이라고 부른다.
그리고 그 업무에 필요한 데이터를 _핵심 업무 데이터_ 라고 부른다. 

_핵심 규칙_ 과 _핵심 데이터_ 는 본질적으로 결합되어 있고, 보통 객체로 만드는데 이러한 유형을 엔티티라고 한다.

- 엔티티(엔터프라이즈 업무규칙)
  - 엔티티는 컴퓨터 시스템 내부의 객체, 핵심 데이터를 기반으로 동작하는 일련의 조그만 핵심 규칙을 구체화한다.
    엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.
    엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.
    (???) 내가 하는 플젝의 핵심 규칙은 뭘까 -_-
  - 엔티티의 유일한 요구조건은 핵심 데이터와 규칙을 하나로 묶어서 별도의 모듈로 만들어야 한다.
  - 고수준 개념: 다양한 어플리케이션에서 사용될 수 있도록 일반화 됨.

- 유스케이스(애플리케이션 업무규칙)
  - 애플리케이션에 특화된 업무 규칙을 설명한다.(시스템이 사용자에게 어떻게 보이는지를 설명하는 것이 아니다.)
  - 엔티티 내부의 핵심 업뮤 규칙을 어떻게, 언제 호출할지를 명시하는 규칙을 담는다 (엔티티를 어떻게 사용할지를 제어)
  - 엔티티 사이의 상호 작용을 규정한다. 
  - 엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못한다. (_의존손 역전 원칙을 준수하는 의존성 방향_)
  - 저수준 개념: 단일 애플리케이션에 특화, 입.출력에 보다 가깝게 위치함, 엔티티에 의존- 

업무 규칙은 소프트웨어 시스템이 존재하는 이유이고, 핵심적인 기능이다.
업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아있어야 한다.
이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인 되어야 한다.
업무규칙(엔티티?)은 시스템에서 _가장 독립적이며 가장 많이 재사용할 수 있는 코드_ 여야 한다.



# 21장 소리치는 아키텍쳐(아키텍쳐 목적)
좋은 아키텍쳐는 유스케이스를 그 중심을 둔다. -> 유스케이스에 대해 집중해야한다.
프레임워크는 사용하는 도구일 뿐, 아키텍처가 프레임워크나 도구, 환경에 전혀 구애받지 않도록 기술되어야 한다.

웹은 전달 매커니즘(입출력장치)이며, 이것은 애플리케이션의 세부사항이므로 시스템 구조를 지배해서는 절대 안된다.
아키텍처는 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다.

> 프레임워크, 웹 세부사항에 속지말자



# 22장 클린 아키텍쳐

아키텍쳐와 관련된 아이디어들을 보면 목표는 같다. _"관심사의 분리"_ 이다.
소프트웨어를 계층으로 분리 -> 관심사의 분리라는 목표 달성!
각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

이들 아키텍쳐는 다음과 같은 특징을 가진다.
- 프레임워크 독립성
- 테스트 용이성
- UI 독립성
- 데이터베이스 독립성
- 모든 외부 에이전이에 대한 독립성


- 클린 아키텍쳐의 계층(경계)
1 -> 4로 갈수록 바깥 계층 그리고 저수준
  1 엔티티 - 엔터프라이즈 업무규칙
  2 유스케이스 - 애플리케이션 업무규칙
  3 MVC 아키텍처 - 인터페이스 어댑터
  4 DB, 웹 프레임워크, UI - 프레임워크와 드라이버

아키텍쳐 의존성 규칙
소스 코드 의존성은 반드시 안쪽(엔티티)으로, 고수준의 정책을 향해야 한다. 
내부 층에 속한 요소는 외부 층에 속한 어떤 것도 알지 못한다.
특히 내부 층에 속한 코드는 외부 층에 선언된 어던 것에 대해서도 그 이름을 언급해서는 안된다.
우리는 외부 층에 위치한 어떤 것도 내부 층에 영향을 주지 않기를 바란다.

소프트웨어 계층을 분리하고 의존성 규칙을 준수하면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.
데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할 수 있다.


# 23장 프레젠터와 험블 객체
험블 객체 패턴은 디자인 패턴으로, _테스트하기 어려운 행위_ 와 _테스트하기 쉬운 행위_ 를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.

테스트하기 어려운 행위
- View
- 데이터베이스: 데이터를 직접 핸들링하기 때문에 테스트가 어려움

테스트하기 쉬운 행위
- 프레젠터
- 유스케이스

경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다.
험블 객체 패턴을 통해 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

[리액트 훅스와 험블 객체 패턴](https://blog.coderifleman.com/2021/04/21/react-hooks-and-humble-object-pattern-and-tests/)

# 24장 부분적 경계

전체 경계를 구축하기 위해서는 많은 시간과 비용이 든다. 때문에 부분적 경계를 고려하여 구현해볼 수 있다. 

부분적 경계의 방법들 
  - 마지막 단계를 건너뛰기
    독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 방법
  - 일차원 경계
    전략 패턴으로 단일 인터페이스 사용
    완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 
  - 퍼사드
    의존성 역전은 희생하는 방법이고, 경계는 Facade 클래스로만 간단히 정의된다.
    Facade class에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 클래스로 호출을 전달한다.
    클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.
    Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다. -> 정적 언어였다면 서비스 클래스 중 하나에서 소스 코드가 변경 되면 Client도 무조건 재컴파일 해야됨

    
[디자인패턴 - 전략패턴](https://victorydntmd.tistory.com/292)
[디자인패턴 - 퍼사드](https://lktprogrammer.tistory.com/42)


# 25장 계층과 경계

시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리 된다. 
그렇다고 모든 흐름을 경계로 구분해야 하는가? 아니다. 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다. 
현명하게 추측해야한다.. 완벽하게 구현할 경계는 무엇이고, 부분적으로 구현 또는 무시할 경계가 무엇인지... 
시스템의 발전함에 따라 주의를 기울이며 지켜봐야한다. 

_목표를 달성하려면 빈틈없이 지켜봐야한다._

> 아 -_- 프로젝트에 대한 많은 애정으로 쭉.... 지켜보며 뭘 가지쳐야하는지 계속 생각을 하라는 것...? (어쩌라고.. )