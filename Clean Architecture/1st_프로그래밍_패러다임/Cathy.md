# 프로그래밍 패러다임 

패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다. 
각 패러다임은 프로그래머에게서 권한을 박탈한다. 

각 패러다임에서 우리에게 무엇을 빼앗는다는 것을 인지해보면,
구조적_goto문(무분별한 점프), 
객체지향_함수 포인터, 
함수형_할당문 
을 앗아간다. 이 부분을 인지하며 패러다임을 생각해보자.


## 구조적 프로그래밍
> 제어흐름의 직접적인 전환에 대해 규칙을 부과한다. 

- 구조적 프로그래밍의 탄생
if/then/else 와 do/while 제어 구조의 발견으로 모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 이라는 세 가지 구조만으로 표현할 수 있음을 발견,

모듈을 증명 가능하게 하는 제어구조가 모든 프로그램을 만들 수 있는 제어구조의 최소 집합과 동일하다는 사실을 발견
= 구조적 프로그래밍의 탄생

- 기능적 분해(세분화)
구조적 프로그래밍으로 모듈을 증명 가능한 작은 단위로 재귀적으로 분해 가능
고수준 -> 저수준 함수들로 분해
_대규모 시스템을 모듈과 컴포넌트로 나눌 수 있게 됨_

- TDD 
소프트웨어는 과학의 영역(귀납법).
테스트를 죽어라 한다는 것은 틀림을 발견하기 위한것
틀림이 발견되지 않는다면 어느정도 맞다고 생각하고 사용하는 것

* 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요.
* 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.


## 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향(Object-Oriented) 설계 원칙을 이해하고 응용하는 데서 출발

- 객체지향이란 무엇인가? 
데이터와 함수의 조합? 이라고 하기에는 그 이전부터 프로그래머가 해왔던 방식이다.
캡슐화, 상속, 다형성 3가지 개념을 적절하게 조합한 것? 또는 객체지향 언어는 최소한 이 3가지 요소를 지원해야 한다고 하는데
이 3가지 개념은 무엇인가? 객체지향과 어떤 관계가 있는가? 

_캡슐화_ 는 오히려 객체지향에서 훼손 되었다. (C언어에서 완벽히 가능)

_상속_ 은 객체지향 언어가 확실히 제공한다. 그러나 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. 
  - OO언어가 고안되기 전에도 상속과 비슷한 기법이 사용됨
  - 하지만, OO언어에서 _업캐스팅_ 이 암묵적으로 이루어 짐으로 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있음

_다형성_ 은 이전에도 사용되었든 기법이다. 하지만 이는 함수를 가리키는 포인터를 사용해 왔던 것
  - 함수 포인터는 위험하다는 사실 (특정 관례를 수동으로 따르는 방식)
  - 객체지향 언어는 특정 관례를 없애주며, 다형성을 쉽게 처리
  - 이로 인해 _객체지향은 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론_ 지을 수 있음


- 다형성이 가진 힘
  - 의존성 역전
    전형적인 호출 트리의 경우 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다. 
    그러나 다형성이 끼어 들면서, 소스코드 의종성이 제어흐름과 반대로 흐를 수 있게 되었다 (의존성 역전)
    객체지향 언어는 다형성을 안전하게 제공한다는 사실이 _소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻_


- 다형성으로 생기는 변화
객체지향언어의 아키텍쳐는 _소스 코드 의존성 전부에 대한 뱡향을 결정 할 수 있는 절대적인 권한_ 을 갖는다.
이로 인해, 컴포넌트는 개별적이며 독립적으로 배포가능하게 된다. 

  - 배포 독립성(independent deployability)
    각 컴포넌트는 개별적이며 독립적으로 배포 가능해진다.
    시스템의 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 _업무 규칙에 의존_ 하도록 만들 수 있다.(업무 규칙의 플러그인화)
    업무 규칙의 소스 코드에서는 UI나 데이터 베이스를 호출하지 않는다.
    업무 규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일(컴포넌트 사이에 의존하지 않음)
    독립적으로 배포할 수 있다.

  - 개발 독립성(independent developability)
    시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.

* 객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
* 객체지향을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있음
* 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있음 

## 함수형 프로그래밍
함수형 프로그래밍 패러다임의 핵심이 되는 기반은 _람다(lambda)계산법_ 이다. 
> 불변성으로 심볼의 값이 변경되지 않는다는 개념

- 함수형 언어에서 변수는 변경되지 않는다
  클로저 프로그램에서는 이러한 가변 변수가 전혀 없다.
  클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

- 불변성과 아키텍처
  경합(race) 조건, 교착상태(deadlock), 동시 업데이트(concurrent update)문제는 모두 가변 변수로 인해 발생한다.
  불변성을 실현하고 싶지만 현실에서 제약이 있기에 타협을 해야한다.
  어떤 타협이 필요한가? 

- 가변성 분리
  - 가변 컴포넌트와 불변 컴포넌트로 분리
    불변 컴포넌트에서는 순수하게 함수형 방식, 어떤 가변 변수도 사용되지 않는다.
    불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수한 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
  - 트랜젝션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호
    변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리

- 저장공간과 처리능력
  - 이벤트소싱
    상태가 아닌 트랜젝션을 저장하는 전략(순차적으로 발생하는 이벤트를 모두 저장)
    필요한 상태 정보의 트랜잭션만 처리 -> 저장공간 확보
    CR만 수행하기에(delete, update가 없음) 동시 업데이트 문제가 발생하지 않음


* 소프트웨어는 급격히 발전하는 기술이 아니다. 도구는 달라졌지만, 소프트웨어 핵심은 여전하다
* 프로그램은 _순차, 분기, 반복, 참조로 구성된다._ 그 이상 그 이하도 아님



내가 고민해보야 할 점
다형성을 제대로 이해하고 코드에 사용했었나? 
현재 코드들에서 다형성을 적용할 수 있는 부분이 어디가 있을까? 
소프트웨어 핵심은 여전하다.

이벤트소싱 -> 스냅샷 -> 파이어베이스 스냅샷 개념 ? 

ㅈㄴ 재밌다


[소프트웨어 안정성](https://endorphin0710.tistory.com/122)
> 비슷한 느낀점 -_- 
[goto 문](https://boycoding.tistory.com/187)
[캐스팅](https://computer-science-student.tistory.com/335)
[다형성-1](https://brunch.co.kr/@kd4/4)
[다형성-2](https://steady-coding.tistory.com/446)
[이벤트 소싱](https://mjspring.medium.com/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%86%8C%EC%8B%B1-event-sourcing-%EA%B0%9C%EB%85%90-50029f50f78c)