## 설계와 아키텍쳐?
- 설계와 아키텍쳐는 아무런 차이가 없다.
보통은 아키텍쳐를 고수준에서의 설계로 이해하기는 하지만, 둘은 단절되지 않은 개념이다.
- 소프트웨어 아키텍쳐의 목표: 필요한 시스템을 만들고, 유지보수하는 데 투입되는 인력 최소화
즉, 장기적으로 수익을 창출하는 시스템을 만드는 것이라 할 수 있다.

## 행위와 아키텍쳐
- 소프트웨어 시스템이 이해관계자들에 제공해야하는 두가지 가치
둘 중 어느것도 부족해서는 안된다.
- 행위: 기능 명세서, 요구사항 구체화
- 아키텍쳐: 소프트웨어가 소프트웨어인 이유는 유연하기위함. 기계의 행위를 쉽게 변경해야한다. 그러기 위해서는 형태에 아키텍쳐가 독립적이어야한다.
- 아이젠하워 매트릭스: 이를 통해 아키텍쳐는 보다 중요한 일, 행위는 보다 긴급한 영역에 가깝다는 것을 인지한다.
- 아키텍쳐를 후순위에 두지 않도록 노력해야한다.

## 벽돌부터 시작하기: 프로그래밍 패러다임
아키텍쳐는 코드로부터 시작하고, 패러다임은 코드를 짜서 프로그래밍을 하는방법을 의미한다.
1. 구조적 프로그래밍: 제어 흐름의 직접적인 전환에 규칙 부여
2. 객체 지향 프로그래밍: 제어 흐름의 간접적인 전환에 규칙 부여 
3. 함수형 프로그래밍: 할당문에 대한 규칙을 부과한다.

이들 패러다임은 프로그래머로부터 권한을 박탈한다.

이 세 패러다임으로 아키텍쳐를 구성 가능하다.

# 1. 구조적 프로그래밍
### 다익스트라의 일
- 수학적 증명을 통한 프로그래밍 추구, 유클리드 계층구조(공리)를 통해.
- 즉 입증된 구조를 가져다가 사용하고, 그러면 코드도 올바를 것이다라고 가정
- goto 문을 제어해 분할 정복 접근법을 사용하고자 했다. 더 작은 모듈로 나누는 것. 그 다음 그 작은 모듈을 증명하는 것
- 이는 순차 실행일 경우 의미가 있는 방법.
- 그러나 이렇게 반복해서 분할한 조그마한 구조를 굳이 증명하려고 하지 않았다.
- 대신 과학적 증명을 통한 방향으로 전개되었다리

### 과학적 증명
- 과학은 올바름을 절대로 입증할 수 없다. 잘못되었음은 입증 가능하다.
- 다만 반증은 가능하다. 서술이 틀렸음을 증명하는 것
- 재귀적으로 분해했던 지난 접근법이 잘못된 것이 아니라, 그 방법을 통해 최대한 모듈을 작게 만든 다음. 그를 테스트하는 방식으로 코드를 입증한다.

# 2. 객체 지향 프로그래밍
어떤 걸로도 크게 설명하기 어려운 개념
크게 세가지 특징이 있다.

### 캡슐화
- 데이터를 숨기고 일부만이 노출되는 이 특징은, 단지 OO 언어만이 갖는 특징은 아니다.
- 더군다나 이들은 완전한 캡슐화가 아니라, 거의 강제하지 않는다. 변수나 함수를 사용하고 보아야하기 때문이다.

### 상속
- 이는 상속도 마찬가지이다.
- 상속을 편하게 해준건 맞으나, 이전 C 언어에서도 개념은 적용되어 있었다.

### 다형성
- 하나의 객체가 여러 타입을 가지는 것. 
- 이 덕분에 플러그인 아키텍쳐가 적용 가능했다.
- 의존성 역전: 기존 제어흐름을 따르는 게 아니라, 소프트웨어의 의존성 방향을 자유롭게 정할 수 있다는 것
- 배포 독립성, 개발 독립성을 이뤄낸다.

결론적으로, 다형성을 이용해서, 소스코드 의존성을 주도할 수 있게 하는 것이 객체 지향 프로그래밍이다.

# 3. 함수형 프로그래밍
- 가변 변수따위는 없다. 변수가 변형되지 않는다.
- 동시성 애플리케이션에서 마주치는 문제, 가변 변수가 아니라면 발생하지 않는다.
- 다만 이 경우, 프로세서의 성능 혹은 저장 공간이 변수다.
- 가변성을 분리하고 (불가변 컴포넌트와 가변 컴포넌트의 분리), 상태를 저장하는 것이 아니라 트랜잭션을 저장해 이벤트 소싱을 이뤄낸다.

 

## 결론
이 모두를 톺아보았을 때, 우리는 결국 하면 안되는 것에 대한 깨달음이 있었다.
구조적 프로그래밍은 직접적인 제어흐름을 제어하고
객체지향 프로그래밍은 간접적 제어흐름을 제어한다.
함수형 프로그래밍은 변수 할당에 대한 규칙을 만든다.

