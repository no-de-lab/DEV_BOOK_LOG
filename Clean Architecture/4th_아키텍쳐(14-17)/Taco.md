야키텍처: 시스템의 생명 주기를 지원

# 아키텍처의 역할
1. 쉽게 시스템을 개발할 수 있도록 만들어야한다.
2. 한번에 쉽게 배포하도록 해야한다.
3. 운영에 필요한 요구를 알려준다. 시스템이 가진 의도를 아키텍처 수준에서 알아볼 수 있게해야한다. 
4. 유지보수 비용을 크게 줄인다. 컴포넌트 분리 및 안정된 인터페이스를 둚으로 탐사 비용 줄인다. 
5. 중요한 것은, 선택사항을 가능한 많이 두어야한다.
6. 하드웨어 장치와도 분리해야한다. 
7. 세부사항에 대한 결정을 최대한 미루는 방식으로 아키텍트를 설계해야한다.

# 중요한 개념 -> 결합 분리: 계층과 유스케이스의 결합을 분리하는 것.
1. 소스 수준
2. 배포 수준
3. 서비스 수준

> 중요한 것은 언제든 좋은 아키텍처를 위해 원래 형태로 돌아갈 수 있어야한다는 것.

# 아키텍처는 선을 그어야한다.
관련이 있는 것과 없는 것 사이의 선을 긋는다. 
단일 책임 원칙으로, 어디에 선을 그어야할지 파악한다.


# 경계를 횡단하기
만들어놓은 경계를 횡단하는 것: 소스 코드 의존성 관리를 함으로 가능

가장 단순하고 흔한 경계는 물리적으로 엄격히 구분되지 않는 형태이다. (구분되는 단순한 형태는 동적 링크 라이브러리)
- 배포 관점에서는 단일체는 경계가 드러나지 않는다. 
- 단일체 > 배포형 컴포넌트 > 로컬 프로세스 > 서비스 순으로 물리적 경계가 강해진다.

# 정책과 수준
정책은 신중히 분리되어야 하며, 동일한 시점에 변경될 시 동일한 수준에서 정책이 위치하여야한다.
이런 정책은, 입력과 출력과 얼마나 가까이 있는지에 따라서 수준이 논의될 수 있다.
가까이 있을수록 저수준 정책, 더 자주 바뀌는 정책이다.

# 업무규칙
- 사업 자체에 핵심적인 규칙 = 핵심 업무 규칙
- 그 규칙은 보통 데이터를 요구하고, 그 데이터를 핵심 업무 데이터로 말한다.
- 자동화된 시스템이 사용되는 방법은 유스케이스다.
- 수동으로 정책을 바꿀 수 있다면 엔티티라고 한다.
- 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 언제 호출할지를 명시한다.
- 엔티티는 고수준, 유스케이스는 저수준
- 따라서 업무 규칙은 시스템에서 가장 독립적이면서도 가장 많이 재사용되어야한다.

# 소리치는 아키텍처
- 좋은 아키텍처는, 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있게한다.
- 유스케이스를 중심에 둔다.
- 웹도 아키텍처는 아니다. 
- 프레임워크도 도구일 뿐이다.
- 시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 유스케이스를 이해할 수 있어야한다.

# 아키텍처
모든 시스템 아키텍처에 대한 아이디어는 하나의 목표를 말한다.: 관심사의 분리
모두 소프트웨어를 계층으로 분리하여 관심사의 분리라는 목표를 달성할 수 있다. 
프레임워크/테스트/UI/DB/외부 에이전시

### 의존성 규칙
클린 아키텍처를 이루는 엔티티/유스케이스/컨트롤러, 게이트웨이 등/외부 인터페이스는 안에서부터 동심원을 이룬다.
안에 있는 것이(엔티티) 고수준의 소프트웨어다. 내부는 외부에 대하여 아무것도 알지 못한다.

- 엔티티: 전사적 핵심 업무 규칙을 캡슐화한다.
- 유스케이스: 애플리케이션에 특화된 업무 규칙을 포함한다. 
- 인터페이스 어댑터: 데이터를 내외로 편리하게 바꾼다.
-프레임워크와 드라이버: 모든 세부사항이 위치하는 곳

원의 개수는 달라질 수 있지만, 의존성 규칙은 지켜야한다. 
- 그러나, 의존성 규칙이 달라져야할 경우, 의존성 역전 원칙을 사용하여 해결해야한다. 
그 상황이 발생할 때, 데이터 구조는 가장 간단한 데이터 구조로 이뤄져있다. 

# 프레젠터와 험블객체
### 험블객체란
디자인 패턴, 테스트하기 어려운 행위와 쉬운 행위를 분리가 쉽게 고안.
애플리케이션 > 프레젠터에 객체 전달>프래젠터 포맷팅 문자열 고안 > 뷰모델이라는 데이터 구조에 담음 > 뷰는 뷰 모델에서 이를 찾음.

그외에 뷰가 맡은 역할은 없어서, 뷰는 humble 객체다. 

데이터베이스와 유스케이스 인터랙처 사이에서, 데이터베이스 구현체는 험블 객체다. ORM은 게이트웨이 인터페이스와 데이터베이스사이에서 또 다른 험블객체 경계를 형성한다. 

결국, 각 아키텍처 경계마다 험블 객체를 발견 가능하고, 험블 객체 패턴을 이용해 전체 시스템의 테스트 용이성을 높인다.

# 부분적 경계
그러나 경계를 만드는 데는 비용이 많이든다. 
그래서 부분적 경계를 생성하는 방법을 제시한다.


- 마지막 단계 건너뛰기
독립적으로 컴파일하고 배포할 수 있는 컴포넌트 작업 모두 수행 후, 단일 컴포넌트에 모아만 두는 것이다.
버전 번호도 없고, 배포 관리 부담도 없다.
- 일차원 경계
양방향으로 격리된 상태를 유지해야하는 완벽한 아키텍처와는 달리, 한쪽만 있다. 
이 경우 비밀 통로가 생길 수 있다. (클라이언트와 Impl사이)
- 퍼사드 패턴
경계는 퍼사드 클래스로만 간단히 정의하고, 클라이언트는 퍼사드로만 호출한다. 
하지만 이 경우 소스 코드가 변경되면 클라이언트도 무조건 재컴파일해야한다는 단점이있다.


# 계층과 경계

아키텍처 경계는 어디에나 존재한다. 어디에 경계를 두어야하고 부분적으로 구현할 곳이 어디고 무시할 곳이 어딘지 우선순위가 필요하다.
프로제그 초반에는 좀 지켜보고, 조짐을 파악하고 비용을 가늠한 뒤 검토한다. 

# 메인 컴포넌트

나머지 컴포넌트를 생성하고 조정하며 관리하는 가장 낮은 수준의 정책.
궁극적 세부사항. 시스템의 초기 진입점.

애플리케이션의 플러그인 역할, 제어권을 애플리케이션의 고수준 정책으로 넘긴다.

# 크고 작은 모든 서비스들

모든 서비스가 반드시 아키텍처 관점에서 중요해야만 하는 것은 아니다.
기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스를 생성하면, 의존성 규칙 준수 여부와는 관계없이 큰 도움이 된다.

## 서비스들로 분리하면?
서비스 사이의 결합은 확실히 분리될 것이다.근데, 프로세서 내의 혹은 네트워크 상의 공유 자원 때문에 결합될 가능성은 여전히 존재한다.

개발 및 배포 시스템의 오류도 있다.

굳이 서비스 기반 시스템이 아니어도, 모노리틱 혹은 컴포넌트 기반 시스템으로도 가능하며, 
서비스라 해서 항상 독립적으로 개발 배포 운영할 수 있는 것은 아니다.

## 야옹이 문제
서비스 중심 아키텍처가 가지는 위의 문제점은, 새로운 기능이 고안되었을 때 모든 서비스를 바꾸어야한다는 점에서 전략을 아주 세심히 조정해야한다.

## 이를 해결하는 아키텍처
다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다. 

## 컴포넌트 기반 서비스
서비스를 컴포넌트 단위로 분할하고, 이 서비스들은 시스템의 아키텍처 경계를 정의하지 않는다.
이를 정의하는 것은 서비스 내에 위치한 컴포넌트다.

# 테스트 경계
아키텍처 관점에서는 모든 테스트가 동일하다.

테스트는 세부적이며 구체적이고, 의존성은 테스트 대상이 되는 코드다.
테스트는 시스템의 설계 밖에 있는 것은 아니다. 
다만 시스템에 강하게 결합되어서는 안된다. 

# 클린 임베디드 아키텍처
- 펌웨어는 개별 하드웨어에 내장되는 소프트웨어다.
하드웨어와 결합된 소프트웨어는 하드웨어 의존성 때문에, 오래도록 살아남기는 어렵다. 
- 많은 임베디드 시스템 소프트웨어는 동작하게 하는데만 집중하는데, 이는 세세한 최적화가 뒷받침 되어야만 한다.

### 타깃-하드웨어 병목 현상
- 계층
  - 하드웨어 위 펌웨어, 그위에 소프트웨어
  - 하드웨어와 펌웨어, 소프트웨어 사이의 경계를 분명하게 해야한다.

- 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라.

