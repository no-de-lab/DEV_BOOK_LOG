# 아키텍쳐란(15장)?


아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는데 있다.

- 개발
  - 시스템을 쉽게 개발할 수 있도록 만들어야 한다.
- 배포
  - 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 목표를 두어야 한다.
- 운영
  - 시스템을 운영하는데 필요한 요구도 알려준다.
    시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급(first-class) 엔티티로 격상시키고, 
    이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다. -> 개발과 유지보수에 큰 도움
- 유지보수
  - 신중한 아키텍쳐는 *탐사비용을 줄일 수 있다.
- 선택사항 열어 두기
  - 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다. (무슨 말인지 아직 체감이 잘 안됨)
  모든 소프트웨어 시스템은 정책(policy)과 세부사항 구성요소로 분해할 수 있다.
  정책 요소는 모든 업무 규칙(Business Rules)과 업무 절차(Procuedures)를 구체화
    정책이란 시스템의 진정한 가치가 살아 있는 곳
  세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책에 영향을 끼치지 않는다. 
    ex) 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등


아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다. -> ??? 

> 탐사: 기존 소프트웨어에 새로운 기능을 추가 / 결함을 수정할 때, 어디를 어떻게 추가/수정 하는가를 결정할 때 드는 비용


> 내 생각
정책과 세부사항에 대해서 정확히 이해를 하지 못했는지 뭔말하는지 정확히 와 닿지가 않는다. 
일단 분리 분리 분리! 
컴포넌트든 정책과 세부사항 사이든 '명확한 목적에 따라 분리하는 것'이 좋은 아키텍쳐의 방향으로 가는 것으로 이해가 된다.

# 독립성(16장)
좋은 아키텍처는 아래 4가지를 지원해야한다.

- 유스케이스
  시스템의 의도를 지원해야 한다는 뜻
  아케텍쳐의 최우선 관심사는 유스케이스
- 운영 (???)
  시스템이 어떠한 조건으로 일을 처리해야 한다면, 그에 맞는 운영 작업을 혀용할 수 있는 형태로 아키텍처를 구조화 해야한다.
  각 컴포넌트를 적절히 격리하고 유지된 상태로 운영될 경우, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 
  스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬어질 것이다
- 개발
  독립적으로 개발 가능한 컴포넌트 단위로 시슴템을 분할 할 수 있어야한다.
- 배포
  좋은 아키텍처는 시스템이 빌드된 후 _즉각 배포_ 할 수 있도록 지원해야 한다.
  그러기 위해 시스템을 컴포넌트 단위로 적절하게 분할
  하고 격리시켜야 한다.

- 선택사항 열어놓기
  좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.
  (선택 사항에 어떤 것들이 있을까?)

- 계층 결합 분리
  아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용
  그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다.

- 유스케이스 결합 분리
  유스케이스는 시스템을 분할하는 매우 자연스러운 방법
  유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각이기도 함
  각 유스케이스는 
    UI의 일부, 
    애플리케이션 특화 업무 규칙이 일부, 
    애플리케이션 독립적 업무 규칙의 일부, 
    데이터베이스 기능의 일부를 사용함
  따라서 우리는 시스템을 수평적 계층으로 분할하면서 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할할 수 있음 (???)

- 개발 독립성
  컴포넌트가 완전히 분리되면 개발 팀도 분리된다. -> 아키텍처는 팀 구조를 뒷받침
- 배포 독립성
  유스케이스와 계층의 결합이 분리되면 배포 측면에서고 고도의 유연성이 생긴다.
  (예시가 그렇게 이해되지 않는다. 배포에 대해서 내가 정확히 이해하지 못해서 그럴지두)

- 중복
  중복에는 진짜 중복과 우발적 중복을 구분하라
  진짜 중복은 개발자라면 중복을 제거하거나 줄여야 한다.
  우발적 중복은 진짜 중복이 아니다.(서로 다른 속도와 다른 이유로 변경된다면 중복이 아님)

- 결합 분리 모드

계층과 유스케이스의 결합을 분리하는 방법은 다양함
  - 소스 코드 수준 : 소스 코드 모듈 사이의 의존성을 제어
  - 바이너리 코드(배포)수준 : 배포 가능한 단위(라이브러리, jar 파일, DDL 등)들 사이의 의존성을 제어
  - 실행 단위(서비스) 수준 : 의존하는 수준을 데이터 구조 단위까지 낮출 수 있음


좋은 아키텍처는 _결합 분리 모드를 선택사항으로 남겨두어_ 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.
시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.


> 내 생각
독립적인 아키텍쳐를 지원해야한다는 것 ? 
선택 사항에 어떤 것들이 있을까? -> 결합 분리 모드가 선택사항 중 하나? 

독립적인 구조, 컴포넌트를 결합-분리하여 규모에 따라 적합한 모드를 적용하고, 시간이 지남에도 새로운 것을 큰 무리없이 반영 가능 할 수 있도록 만드는 것이 좋은 아키텍쳐...?


# 경계:선긋기(17장)

어떻게 경계를 하나? -> 관련이 있는 것과 없는 것 사이에 선을 긋는다.

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할
컴포넌트 사이의 화살표가 특정 방향(핵심 업무)을 향하도록 배치

의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것임을 눈치챌 수 있어야 한다.
의존성 화살표는 _저수준 세부사항에서 고수준 추상화를 향하도록 배치_ 된다.


# 경계 해부학(18장)
시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트를 분리하는 경계에 의해 정의됨
경계는 다양한 형태로 나타남

- 경계 횡단하기 
  적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리

경계의 형태들
- 두려운 단일체
  가장 단순하고 흔한 경계는 물리적으로 엄격하게 구분되지 않는 형태
  소스 수준 분리 모드
  배포 관점 → 단일체(monolith) (.vue, .tsx이 묶은 번들파일?)
  가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출

- 배포형 컴포넌트
  아키텍처의 경계가 물리적으로 드러날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리(npm, yarn workspace)
  배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일

- 스레드
  단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있음
  모든 스레드가 단 하나의 컴포넌트에 포함될 수 도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있음

- 서비스
  물리적인 형태를 띠는 가장 강력한 경계는 서비스
  - 서비스는 프로세스로, 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
  - 서비스는 자신의 물리적 위치에 구애받지 않는다.
  - 서비스는 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.
  - 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다.
    -> 이때 발생하는 지연(latency)에 따른 문제는 고수준에서 처리할 수 있어야 함 
  - 저수준 서비스는 고수준 서비스에 '플러그인'되어야 한다.


단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계전략을 사용한다.
실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드(Faacade)에 불과할 때가 많다.

> 내 생각
아 경계라는 것에 대해서 너무 추상적으로 이해했는지 경계 해부학 내용이지만
뭔가 이해가면서도 가물가물하다 
비슷한 얘기를 다른 단어와 상황으로 풀어 말하는 것 같은데
진짜 뭐라하는지 몰겠따 ^_^ 