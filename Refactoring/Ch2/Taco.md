# 리팩터링 원칙
## 리팩터링 정의
겉 동작은 유지하고 가독성과 유지보수를 위해 내부 구조를 변경, 재구성한다.

특정 방식에 따라 코드를 정리하는 것이어야한다. 리팩토링 전후의 코드가 똑같이 동작해야한다. 성능은 바뀔 수 있다. 인터페이스도 바뀔 수가 있다. 

기능개발인지 리팩터링인지 모드를 명확히 해야한다.

## 리팩터링 하는 이유
- 아키텍처 개선: 중복 코드 개선, 수정하는 데 드는 노력을 줄이기
- 소프트웨어 이해가 쉬워진다
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.: 설계가 잘되어있으면 추가 기능을 개발하는 속도가 높아진다. 

## 리팩터링할 때
예시로 3의 법칙이 있다. 처음에는 그냥 하고, 중복으로 하게되면 일단 하고, 세번째로 비슷한 일을 하면 리팩터링한다.

- 준비를 위한 리팩터링: 기능을 새로 추가하기 직전에 리팩터링을 한다. 
- 이해를 위한 리팩터링: 코드가 하는 일을 파악해서 변수명을 바꾸어주고, 긴 함수를 잘게 나누기도 한다. 
- 쓰레기 줍기 리팩터링: 간단히 수정 가능하면 즉시 고치고, 좀 더 걸리는 일은 짧은 메모만 남기고 끝낸 뒤 처리한다. 
- 계획된 리팩터링과 수시로 하는 리팩터링: 위의 세개는 기회가 될 때만 진행하는데, 보기싫은 코드를 발견했을 때에도 리팩터링을 진행한다. 
- 주어진 문제를 몇 주에 걸쳐 조금씩 처리하는 편이 효과적일 때가 많다. 
- 굳이 수정할 필요가 없거나, 처음부터 새로 작성하는 게 쉬울 때 리팩터링할 필요는 없다. 내부 동작을 이해해야 할 시점에 리팩터링을 하면 효과가 있다. 

## 리팩터링 시 고려할 점
- 새 기능 개발시 속도 저하: 속도 저하를 이유로 리팩터링을 금하곤 하는데, 오직 경제적인 이유로 리팩터링이 필요하다. 리팩터링은 기능 추가 시간을 줄여준다.
- 코드 소유권: 나눠져잇으면 리팩터링에 방해가 된다. 함수 이름을 변경할 때, 함수 이름 바꾸기를 적용하면서도 기존 함수 유지를 한다. 함수 본문에서 새 함수를 호출하도록 수정한다. 전반적으로 코드 소유권을 느슨하게 정하는 것이 좋다. 
- 브랜치: 기능별로 브랜치를 나눌 때, 머지(마스터 -> 브랜치 단방향)이 아닌 통합(머지 후 변한 부분 다시 마스터에 통합)시 서로 다른 사람들의 코드가 꼬일 수 있으므로, 자주 통합해야한다. 
- 테스팅은 리팩터링을 할 수 있게 도와주기도 하고 새 기능 추가도 안전하게 진행할 수 있게끔 돕는다.
- 레거시 코드: 테스트 보강을 통해 명료히 리팩토링 할 수 있다. 
- 데이터베이스: 마이그레이션 스크립트를 작성 후, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합한다. 

## 리팩터링, 아키텍처, 애그니
리팩터링은 결국 요구사항 변화에 자연스럽게 대응하도록 돕는다. 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 가장 잘 대응할지 추측하는 것이 아니고, 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 이런 방식을 애그니라고도 부른다. (you arent going to need it)

물론 선제적 아키텍처에 완전히 소홀해도 된다는 게 아니라, 문제를 이해하게 됐을 때 대응하는 편이 좋을 때가 잇다는 뜻이다. 

## 리팩터링과 소프트웨어 개발 프로세스
자가 테스트 코드와 CI, 리팩터링 세가지는 서로 강력한 상승효과를 발휘한다. 

## 리팩터링과 성능
리팩터링하면 소프트웨어가 느려질 수는 있지만 성능을 튜닝하기는 더 쉬워진다. 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다. 

성능은 전체 코드 중 극히 일부에서 떨어진다. 그래서 코드 전체를 고르게 최적화할 것이 아니라, 일단 코드를 다루기 쉽게 만드는 데 집중하고 성능을 올린다. 이렇게 리팩토링 후 최적화는 1) 성능 튜닝 투입시간을 벌 수 있고 2) 리팩터링이 잘 되어있는 프로그램은 성능을 더 세밀하게 분석할 수 있게 한다. 

