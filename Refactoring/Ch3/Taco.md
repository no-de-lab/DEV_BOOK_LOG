## 코드에서 나는 악취
리팩터링 해야할 코드에는 일정한 패턴이 있다. 
### 1. 기이한 이름
코드는 단순하고 명료하게 작성해야한다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하는지 명확히 알 수 있어야한다. 
이름을 정리하다보면 코드도 명료해질 때가 많다.

### 2. 중복 코드
똑같은 코드 구조가 반복되면 하나로 통합하여야한다. 코드가 비슷하긴한데 완전히 똑같지는 않다면, 문장을 슬라이스 하여 비슷한 부분을 한 곳에 모아 함수를 추출 가능한지 살펴본다. 

같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 옮긴다. 

### 3. 긴 함수
옛 언어는 서브루틴을 호출하는 비용이 컸어서 짧은 함수를 꺼렸지만, 요즘은 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다. 

물론 코드를 읽는 입장에서야 이리저리 코드를 파악해야하므로 부담이 되지만, 함수 이름을 잘 지어두면 본문 코드를 볼 이유는 사라진다. 
따라서 함수를 추출하는 작업이 중요하다. 임시 변수는 질의 함수로 바꾸고, 매개변수의 수를 줄인다. 

조건문과 반복문도 추출해내면 좋다. 

### 4. 긴 매개변수 목록
매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다. 
따라서 매개변수를 질의 함수로 바꾸거나, 객체를 통째로 넘기거나, 매개변수 객체를 만들어버린다. 

여러 함수를 클래스로 묶어 공통 값들을 클래스의 필드로 정의한다. 

### 5. 전역 데이터
전역데이터를 주의해야한다. 리팩토링에서 가장 나쁜 사례다. 버그는 끊임없이 발생하고 찾아내기는 어려워진다. 
이를 방지하기 위해 변수를 캡슐화한다. 

### 6. 가변 데이터
무분별한 데이터 수정에 따른 위험을 줄여야한다.
- 변수 캡슐화를 통해 정해놓은 함수를 거쳐야만 값을 수정하게 하거나
- 용도별 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 
- 문장 슬라이드와 함수 추출하기를 사용하고
- 질의 함수와 변경함수 분리하기를 활용한다. 
- setter도 제거한다. 
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶고
- 여러 함수를 변환함수로 묶는다. 
- 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체하는 것이 좋다. 

### 7. 뒤엉킨 변경
SW 구조를 변경하기 쉬운 형태로 조직한다. 
하나의 모듈이 서로 다른 이유들로 인해 여러 방식으로 변경되는 일이 많을 때 문제가 생긴다. 

예를 들자면, 지원해야할 데이터베이스가 추가될 때마다 함수 세개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네개를 바꿔야하는 모듈이 있을 때 꼬인다. 이 둘은 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야한다. 

이 경우, 우선 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다. 

전체 처리과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높으면 각 맥락에 해당하는 적당한 모듈들을 만들어 관련 함수들을 모은다. 

여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 함수 추출하기부터 수행한다. 혹은 클래스 추출을 한다. 

### 8. 산탄총 수술
코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 때 문제가 된다. 이 때는 함께 변경되는 대상들을 모두 한 모듈에 묶어둔다. 

비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶는다. 

데이터 구조를 변환하거나 보강하는 함수들에는 이 함수들을 변환함수로 묶는다. 

우선은 함수 인라인이나 클래스 인라인과 같이 하나로 합치는 것도 좋다. 

### 9. 기능 편애
어떤 함수가 자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 문제가 생긴다. 
그렇다면 함수를 옮겨주거나 특정 부분만 독립함수로 빼낸다음 원하는 모듈로 보내준다. 

어디로 옮길지 명확하게 드러나지 않을 때도 있다.
이럴때는 가장 많은 데이터를 포함한 모듈로 옮긴다. 

### 10. 데이터 뭉치
몰려다니는 데이터를 한 곳에 뭉쳐줄 필요가 있다. 클래스 추출하기로 하나의 객체로 묶거나, 매개변수 객체만들기나 객체 통째로 넘기기를 적용해 매개변수 수를 줄인다. 

뭉치인지 판별하려면, 값 하나를 삭제해봤을 때, 나머지 데이터만으로 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치다. 

### 11. 기본형 집착
프로그래밍 언어가 제공하는 기본형을 그대로 사용할 것이 아니라, 의미있는 클래스로 바꾸거나 객체로 바꿔준다.

### 12. 반복되는 switch문
조건부 로직이 반복해 등장하는 것을 고쳐주어야한다.

### 13. 반복문
반복문을 파이프라인으로 바꿔서, 반복문을 제거한다. 

### 14. 성의 없는 요소
역할이 별로 없는 함수, 클래스, 인터페이스 등의 구조 잡는 프로그램 요소는 함수나 클래스 인라인하는 방식으로 바꾼다. 

### 15. 추측성 일반화 
나중에 필요할거라는 생각으로 당장은 필요없는 모든 종류의 후킹 포인트나 특이 케이스 처리 로직은 없앤다. 

### 16. 임시 필드
특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있는데, 이런 경우 클래스 추출하기로 제 살곳을 찾아준다. 

### 17. 메시지 체인
클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 또 다른 객체를 요청하는 방식을 메시지 체인이라 한다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미하므로 리팩터링이 필요하다. 

최종 결과 객체가 어떻게 쓰이는지를 살피고, 체인을 숨길 수 있는지를 함수 추출->옮기기로 살펴보아야한다.

### 18. 중개자
캡슐화 하는 과정에서는 위임이 자주 활용된다. 
하지만 지나치면 문제가 된다. 그대는 중개자를 제거해야한다. 

### 19. 내부자 거래
모듈들 사이에 사적인 처리부분이 있다면 이를 줄인다. 

### 20. 거대한 클래스
한 클래스가 너무 많은 일을 하지 못하게 한다. 

### 21. 서로 다른 인터페이스의 대안 클래스들
클래스를 교체하려면 인터페이스가 같아야한다. 이때 함수를 옮기고 중복이되면 슈퍼 클래스를 만들지 고려한다.

### 22. 데이터 클래스
데이터필드와 getter/setter method로만 구성된 클래스가 데이터 클래스다. 데이터 저장 용도로만 쓰여서, 다른 클래스가 너무 깊이까지 다룰 때가 많으므로 캡슐화가 필요하다. 

단계를 쪼개어 필요한 동작이 엉뚱한 곳에 있지 않도록 한다.

### 23. 상속 포기
만약 서브 클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 서브클래스를 위임으로 바꾸는 등을 해서 상속 매커니즘에서 벗어나게 해야한다.

### 24. 주석
너무 많은 주석을 남기지 않는다.
