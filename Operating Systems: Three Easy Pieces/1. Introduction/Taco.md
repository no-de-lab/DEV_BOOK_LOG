### 2.4 Persistence
데이터를 어떻게 안정적으로 저장하는지에 대한 것.
OS의 파일 시스템과 연관되어있다.
디스크의 어디에 새로운 데이터를 집어넣고, 다양한 구조에 그를 관리할지를 결정한다.
어떻게 보면 기준이되는 라이브러리같기도 하다.
- 그 외 중요한 용어들: journaling, copy-on-write (write protocol)

### 2.5 Design Goals
OS가 가지는 기본 목표는 시스템이 사용하기 쉽게끔 추상화를 하는 것이다. 
- 프로그램을 작게 나누어, 
- 어셈블리어를 생각하지않고, 로직 게이트를 생각하지도 않고, 트랜지스터에 대해 생각할 필요 없게끔.

또 다른 목표는 높은 성능을 제공하는 것, 즉 오버헤드를 최소화하는 것이다.
- 이는 가상화로 이뤄낼 수 있다. 
- 여기서 오버헤드란, 추가 시간 혹은 추가 공간이될 수 있다. 이를 최소화해야한다.

다른 목표는 보호다. 그는 isolation으로 이뤄낸다.
- 다른 프로그램이 다른 프로그램을 침범하면 안된다.

또한 OS는 끊김 없이 운영되어야 한다. 그래서 신뢰수준이 중요하다. 

그 외에, 에너지 효율성, 보안 등이 중요하다 하겠고, 최근에는 모바일 기기로 인한 모빌리티도 중요한 목표다. 

### 2.6 Some History
- 초기: 그저 라이브러리였다.
많은 것을 하지는 않았고, 자주 쓰이는 함수들을 제공했다. 한번에 한 프로그램만 구동되었다. 어떤 것이 구동될지에 대해 결정하는 것은 Operator가 결정했다. 

이때 Operator는 배치 프로그래밍을 구동하였다. 컴퓨터는, 대화식으로 사용되지는 않았다.
비효율적이었기 때문이다.

- 라이브러리를 넘어: Protection
device 컨트롤을 하게 되었다. 시스템 콜이라는 개념이 만들어졌고, 이는 프로시져 콜보다 하드웨어 명령어나 상태를 더욱 더 control되게끔 하기 위해서였다.

- 멀티 프로그래밍
미니 컴퓨터 시대에 오고서야 OS가 정말로 제 역할을 하기 시작했는데, OS는 여러 job들을 메모리에 올려 작동시켰다. 

메모리 보호와 동시성 이슈를 다루는 것이 메인 고민이 되었다. 

UNIX OS가 등장한 것이 실질적인 발전이었다. 이는 shell, pipe, C programming language compiler를 만들어내었고, 오픈소스 프로젝트라 수많은 파생 걸작들의 탄생에 영향을 주었다.
불행하게도, 유닉스는 그를 만든 회사가 저작권을 가지고 수익을 창출하려들며 널리 사용되는 것이 좀 느려졌다. 그러던 중 PC가 만들어졌다. 

- 현대

PC의 개발로 미니 컴퓨터는 어쩌면 잊혀지는듯했다. (ex. MAC OS)
그러나, PC 운영체제의 여러 문제들을 겪으며, 미니컴퓨터의 기능들을 이 OS에도 집어넣기 시작했다. 

유닉스에게는 다행히도, Linux Torvalds라는 사람이 Unix의 자신만의 버전을 만들어내었다. 그것이 바로 Linuxek. 
인터넷 시대가 발발하며, 많은 회사들은 리눅스를 선택했다. 왜냐면 그것은 무료였고, 쉽게 변경이 가능했기 때문이다. 

그 이후로 계속해서 파생된 기술이 나오면서, 유닉스와 리눅스는 그 어느때보다 죽지않고 살아있다고 볼 수도 있겠다. 