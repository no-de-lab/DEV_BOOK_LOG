스레드로만 동시성을 구현할 수 있는 것은 아니다. 
event 기반 동시성으로 알려진 node.js 와 같은 것들로 동시성 구현이 가능하다. 

문제는 1. 멀티 스레드 애플리케이션에서 동시성을 정확히 관리하는 것이 어렵다는 것이다. 
2. 주어진 시간에 스케줄링된 것에 대해 개발자는 거의 제어권이 없다는 것이다. 그저 개발자는 스레드를 간단히 만들어내어 OS가 잘 해주길 바랄 뿐이다. 

그러나, 그러지 않을때가 있기에, 스레드 없이 동시성 서버를 구축할 방법에 대해서 생각해보고자 한다. 

## 1. Event Loop: Basic Idea
event 기반 동시성은 간단하게, 무엇인가가 일어나길 기다리는 것이다.
만약 어떤 일이 일어나면, 그 이벤트가 어떤 타입인지 파악하고 조금의 요구되는 일들을 하면 된다. 

이벤트 루프라는 것 위에 애플리케이션이 만들어진다. 
메인 루프는 어떤 이벤트를 기다리고, 이벤트가 발생하면 하나씩 처리한다. 그 처리하는 코드를 event handler라고 한다. 

그런데 어떻게 정확하게 이벤트 베이스 서버가 어떤 이벤트가 일어나는지 알 수 있을까? 

## An Important API: select, (or poll)
어떻게 이벤트를 받아낼지 알아야한다. 대부분의 시스템에서는 기본 api를 사용 가능하다. select, poll 시스템 콜을 통하면 된다. 
- select
  - I/O descriptor를 검사한다. read, write, error 등이 준비되었는지 확인하고 준비된 descriptors 수를 반환한다. 
  - descriptor가 읽기와 쓰기가 가능한지 체크한다. 
  - timeout 매개변수가 있다. 
  - poll도 비슷하다. 
  - 이를 통하여 non-blocking event loop를 만들어볼 수 있다. 

## Using select()
조금 더 구체적으로, 어떤 네트워크 descriptor가 들어오는 메세지를 가지는지 확인해보자.

초기화과정 다음에, 서버는 인피니트 루프 과정에 들어간다. 그 안에서, 
1. FD_ZERO라는 매크로를 사용하여 file descriptors 세트를 비우고 
2. FD_SET으로 모든 file descriptors를 그 세트에 포함한다. 예를들면 모든 네트워크 소켓 같은것들 말이다.
3. 서버는 select로 어떤 연결이 데이터가 사용가능한지를 확인한다. 
4. FD_ISSET을 루프안에서 돌려서, 어떤 descriptors에서 데이터가 준비됐는지 확인하고 들어오는 데이터를 처리한다.

## Why Simpler? No Locks Needed
single CPU와 이벤트 기반 애플리케이션에서는, 동시성 프로그램 문제가 없다. 락을 얻고 풀 필요가 없다. 이벤트 기반 서버에서는 다른 스레드에 의해 방해받지도 않는다.
따라서, 동시성 버그가 이 경우에는 없다.

## A Problem: Blocking System Calls
이벤트 기반 프로그래밍이 좋아보이긴 하지만, 만약 이벤트가 시스템 콜을 요구한다면? 

다른 스레드가 없으므로 전체 서버가 call이 끝날때까지 block된다. 이는 큰 자원낭비로 이어질 수 있다. : 따라서 blocking call은 허용되지 않는다.

## A Solution: Asynchronous I/O
이 문제를 해결하기위해 비동기적 I/O가 탄생했다. 
I/O 를 호출하고, 성공적이라면 일을 지속해나갈 수 있다. 그러나, 어떻게 I/O가 완료되었다는 것을 알릴 수 있을까? aio_error()라는 api로 가능하다.
시스템콜은 요청이 완료되었는지 아닌지 체크한다. 

이런 체크는 조금 힘들다. 너무 많은 I/O가 한번에 일어날 경우는 더 심각하다. 이를 해소하기 위하여 인터럽트 기반의 접근을 시스템이 제공한다. 
UNIX signal과 같은 방식을 이용하여 계속해서 시스템에 물어볼 필요가 없게한다. 

## Another Problem: State Management
스레드 기반 코드보다 좀 더 복잡한 이벤트 기반 접근. 
그 이유는 이벤트 핸들러가 비동기적 I/O를 불러내서, 다음 이벤트 핸들러에게 I/O가 끝나면 프로그램 상태를 패키징해서 전달해주어야하는 추가 업무가 있기 때문이다. 

이를 수동 스택 관리라고 한다. 
이에 대한 솔루션은, continuation 이라는 것을 사용하는 것이다. 필요한 정보를 자료구조에 넣고, 그 구조를 바라보며 이벤트를 처리하는 것이다. 

## What is Still Difficult With Events
single CPU에서 multiple CPU로 옮겨가게 되면서, 이벤트 기반 서버의 단순함은 사라졌다. 그래서 동기화 문제가 발생하게 되었다. 결국 lock을 사용하는 것은 불가피한 일이 되었다. 

더불어, 페이징과 같은 시스템 활동과 이벤트 기반 접근이 잘 맞지 않는다. 이벤트 핸들러 페이지 falut가 발생하면, block을 해서 서버가 progress 하면 안된다. 이는 암시적인 블로킹으로 자주 생기면 성능 문제가 생긴다. 

시간이 지날수록 관리가 어려운 단점도 있다. 논블로킹에서 블로킹으로 변하는 루틴에 적응하는 것들이 그 예다.

마지막으로 비동기적 디스크 I/O는 비동기적 네트워크 I/O와 쉽게 합쳐질 수 없다. 
