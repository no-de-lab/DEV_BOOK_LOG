우리가 디스크에게 바라는 것은 크게 세 가지다
1. 빠름
2. 큼
3. 믿을만함

RAID는 여러개의 disk를 모아서 이 요구사항을 이뤄줄 수 있다. 

외적으로는 그냥 디스크처럼 보인다: 내부적으로는 좀 복잡하다. 다양한 디스크와 메모리가 있고, 프로세서가 있다. 오히려 컴퓨터 시스템에 가깝다.
또 좋은 것은, 시스템에 있어서 투명성을 지니고 있어서, 호스트 시스템으로 하여금 이를 큰 디스크로 보게한다는 것이다. 그래서 많은 이들이 이를 쉽게 사용하게 하였다. 

## 1. Interface and RAID Internals
file msystem이 논리적 I/O 요청을 RAID에게 하면, 내부적으로 어떤 디스크에서 이를 접근해야할지 계산하고 한개 혹은 그 이상의 물리적 I/O를 발행한다. 
이 물리적 수준은 레이드 레벨에 달렸다. 

## 2. Fault Model
디스크 문제를 파악하고 회복하도록 설계되었다.
- fail-stop: disk는 일하거나 실패하거나의 상태를 가진다. 
  - 디스크가 실패하면 이는 쉽게 탐지된다는 가정이 있다. 

## 3. How to Evaluate a RAID
- 용량: N개의 디스크와 B개의 블록 -> N * B
- 신뢰성: 전체 디스크가 fail할 수 있는 것만 가정한다.
- 성능: 구하기 어렵다. 왜냐면 디스크 어레이에 있는 workload마다 다르기 때문이다. 

## 4. RAID Level 0: Striping
사실 전혀 RAID가 아니다: 중복이 없다. 그러나, 훌륭한 성능과 용량을 보여준다. 
- block을 라운드 로빈 방식으로 흩트려 놓는다: 같은 줄에 있는 블록들을 스트라이프라 불른다. 
  - 두개의 블록들을 다음 디스크로 가기전에 놓을 수도 있는데, 이 경우는 두개의 블록 사이즈 = 청크사이즈가 된다. 
  - 이 청크 사이즈는, 성능에 큰 영향을 미친다. 

### 청크 사이즈
- 작은 청크 사이즈는 한 파일에서의 병렬성을 높이지만 크기가 작기 때문에 찾는 시간이 걸린다. 
- 큰 청크 사이즈는 병렬성은 낮추지만, positioning time을 줄인다. 
- 대부분의 array들은 큰 청크 사이즈를 사용한다.

### 
