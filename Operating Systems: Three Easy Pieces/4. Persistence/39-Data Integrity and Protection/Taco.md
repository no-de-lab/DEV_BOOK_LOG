어떻게 스토리지 시스템이나 파일 시스템이 데이터가 안전하다는 것을 보장하는가? 

## 1. Disk Failure Modes
disk는 오류가 날 수도 있고, 완벽하지 않다. 
초기 RAID 시스템에서 실패란, 모든 디스크가 일하고 있거나 모두 fail 했거나다. 
 
현대 디스크는 대부분이 일하는 것 같지만 하나에서 그 이상의 블록을 접근하는 데 문제가 있다. 
- latent-sector errors
- block corruption
이 둘이 싱글 블록 실패에서 자주 보이는 유형이다.

- LSE는 디스크가 상처났을 때 발생한다. 그럼 비트가 읽히지 않는다. 
  - cosmic ray가 비트를 건너 뛸수도 있어서 부정확한 내용을 읽게 되기도 한다. 
- 디스크가 corrupt해서 블록을 틀린 장소에 쓰기할 수도 있다. 
- 이 모두는 잘 일어나지는 않지만, 저렴할수록 더 자주 일어난다. 

## 2. Handling Latent Sector Errors
에러 다루기가 상대적으로 쉽다. 쉽게 파악되기 때문이다. 전체 디스크가 실패하면 RAID는 그를 재건하려고 한다. RAID-4/5에서는 패리티라는 것을 두어서 해당 블록에서 읽어온다. 그런데 만약 재건 중에, LSE가 다른 디스크에게 발견되면 성공적으로 재건이 일어날 수 없다. 
이를 해결하기 위해 몇몇 시스템들은 중복 수준을 추가한다. ex. RAID-DP는 두개의 패리티를 둔다. 

## 3. Detecting Corruption: The Checksum
이 문제는 겉으로 보이지가 않는다. 그래서 찾아내는 게 어렵다. 
일단 발견하면, 회복하면 되지만 발견이 어려우므로, checksum이라는 것을 이용한다. 

- 체크섬은 데이터 청크를 인풋으로 가져가는 함수 결과다. 조금의 결과 내용을 생성한다. 
- 체크섬은 시스템으로 하여금 데이터가 바뀌거나 훼손되었는지 파악할 수 있게한다. 

### Common Checksum Functions
다양한 함수가 체크섬을 계산하는 데 사용된다. 얼마나 데이터 고결성을 보호하면서도 빠른지에 따라 달라진다. 
- 제일 간단한 함수는 XOR
  - 간단하지만 한계가 있다. 
- addition 함수도 있다. 빠르다. 
- fletcher checksum: 안전하다.
- cyclic redundancy check: 가장 많이 사용. 계속해서 수를 나눈다. 나머지가 값이다. 
- 완벽한 체크섬은 없다. 

### 체크섬 레이아웃
체크섬은 보통 크기가 작다. 디스크는 섹터 사이즈 청크로만 남아있을 수 있다. 
한가지 레이아웃 방법은 체크섬 하나 섹터 하나인데, 사이즈를 맞추기가 쉽지않다. 
다른 방법은 한 곳에 모두 체크섬을 두고 다음에 블록들을 두는 방법인데, 이는 비효율적이다.체크섬 한번 읽고, 체크섬 업데이트 하고, 데이터 블록도 쓰기를 해야한다. 
첫번째 방법은 쓰기를 한번만 하는 것에 비해 많이 한다. 

## 4. Using Checksums
block D를 읽을 때, file system or storage controller는 체크섬도 읽는다. 이를 stored checksum이라 한다. 
또한 client는 회수한 D로부터 computed checksum을 읽어오는데, 

- 스토리지와 컴퓨티드 체크섬이 같으면 not corrupted
- 다르면 corrupted다. 
- 이를 해결할 수 있는 방법은 사실 중복값들이 많았다면 카피본을 쓰면 된다는 것이지만 없다면 에러를 리턴하는 수밖에 없다.

## 5. New Problem: Misdirected Writes
Storage 시스템이나 디스크 컨트롤러가 잘못 지시해서 이상한 곳에 쓰기를 해버리는 문제. 

이 문제는 각 체크섬에 추가적 정보를 적는 것으로 해결된다. (physical ID)
디스크 정보를 각 체크섬에 중복으로 적어줌으로써 오류를 방지할 수 있다.

## 6. One Last Probelm: Lost Writes
write가 되었지만 유지되지는 않아서 블록 안에 예전의 내용이 들어가 있다. 
이는 체크섬으로도, 물리적 ID의 추가로도 해결할 수가 없다. 

클래식한 해결법으로는 write verity, read-after-write가 있다. 그러나 이건 너무 느리다. I/O를 두배 늘리기도 한다. 

몇 시스템은 이 lost write에 대한 체크섬을 추가하기도 한다. ex. Zettabyte File System은 모든 블록에 대한 간접 블록을 두어서, 데이터가 없어져도 체크섬이 예전 데이터와 불일치하게 한다.

## 7. Scrubbing
언제 체크섬이 체크될까? 
데이터가 액세스될 때겠지만, 대부분의 데이터는 드물게 접근되고 체크되지 않은 상태로 남는다. 이는 문제다. 이를 해결하려고 disk scrubbing을 진행해서 정기적으로 모든 블록들을 읽어서 체크섬이 여전히 유효한지 확인한다. 

## 8. Overheads Of Checksumming
1. 공간
   - 디스크 자체: 각 체크섬은 디스크를 차지하고, 그 공간만큼은 디스크 못 쓴다. 
   - 시스템 메모리: 데이터에 접근할 때 체크섬을 위한 메모리 공간도 필요하다. 
2. 시간
   - 공간보다 시간이 좀 더 오버헤드가 크다. 
   - 적어도 cpu는 체크섬을 각 블록마다 체크해야한다. 이를 줄이기 위해서 데이터 복제와 체크섬을 한번에 한다. 
   - 그 외에도 체크섬이 데이터와 따로 있거나 I/O가 추가적으로 필요할 때 시간이 필요하다. 
