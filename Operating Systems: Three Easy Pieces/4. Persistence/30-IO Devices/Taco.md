I/O 장비와 OS 사이의 상호작용에 대한 내용.
- 어떻게 I/O가 시스템과 결합되는가? 

## System Architecture
### classic 하게는, 
- 하나의 CPU와 메모리 버스를 통해 메인 메모리와 연결되어있고,
- I/O bus(PCI)로 몇몇 그래픽과 높은 성능의 io 장비 연결한다.
- 그 외에는 느린 장비 연결 (ex. 키보드, 마우스..)

이들은 계층구조로 이루어졌는데, 왜 계층구조가 필요할까? 
1. 물리적 이유: 더 빠르려면 더 가까워야한다.
2. 비용: 높은 성능을 위한 bus 제작은 비싸다. 

### 현대에 와서는 
- CPU를 사이에 두고 메모리 시스템과 높은 성능의 그래픽 카드같은 것들이 연결되어있고
- DMI를 통해 IO 칩을 연결했고, 그 칩에 다른 디바이스가 연결되어있다. 
  - 오른쪽에는 disk
  - 아래에는 Universal Serial Bus (ex. keyboard)
  - 왼쪽에는 네트워크같은 높은 성능 시스템이 연결되어있다.

## Canonical Device
- Hardware Interface
  - 소프트웨어처럼, 하드웨어는 인터페이스를 제공해서 소프트웨어로 하여금 하드웨어를 다루게 한다. 
- Internal structure
  - 추상적인 부분을 실행하게 되는 부분. 메모리나 cpu 같은 것들이 포함된다. 

## Canonical Protocol
Interface에는 세가지 레지스터가 있다. 
- status
- data
- command

OS는 이 레지스터를 이용해서 디바이스를 다룬다. 
이 과정에서 status를 확인해서 작동 중인지 아닌지 확인, 작동 중이라면 기다린다. data를 통해 필요한 데이터를 쓰고 읽고, command를 통해 명령한다. 

이는 간단하지만, 비효율적이다. 

하드웨어가 작동중이면 하염없이 기다리는 것은 cpu 낭비이기 때문이다. 

## Lowering CPU Overhead with Interrupts
이를 인터럽트로 해결한다. 
디바이스가 작업을 끝내면 하드웨어 인터럽트를 일으켜서 cpu가 헐레벌떡 OS로 와서 인터럽트 핸들러나 인터럽트 서비스 루틴을 따른다. 

인터럽트로 I/O 작업을 디스크가 하고있을 때, CPU는 다른 작업을 할 수 있어서 이용률을 높일 수 있다.

그러나, 항상 좋은 것은 아니다. 
- 이것에도 오버헤드가 있어서 다른 프로세스로 옮겨지고 다시 돌아오는 시간을 생각해볼 때, 아주 빠르게 진행해야하는 프로세스에는 적절하지않다.
- 또한 네트워크 내에서, 커다란 스트림 패킷이 들어오는데 다 인터럽트한다고 생각해보면, livelock을 발생시킬 수 있다.
  - 그저 인터럽트만 처리하고 있는 것이다.
  - 이 경우는 그냥 waiting 하는 게 낫다. 
- 이런 문제 때문에 그냥 디바이스는 인터럽트 전에 조금 기다려서 다른 요청이 끝난 뒤에 다른 인터럽트들과 한꺼번에 전달한다. 

## More Efficient Data Movement With DMA
불행하게도, 큰 크기의 데이터를 이동해야한다면 그것을 copy하는 시간도 cpu에게는 부담이다.
그를 위해 DMA라는 OS-disk 사이의 장치를 두어서, 메모리 내 데이터가 어디 있고 얼마나 있는지를 OS로부터 듣고 그를 복사하고 disk에 write한다. 
모든 작업이 끝나면 인터럽트를 발생시키고 cpu는 다시 돌아온다.

## Methods of Device Interaction
어떻게 디바이스와 소통할 것인가? 
1. IO 명령어
   - OS가 data를 특정 디바이스 레지스터로 보내는 방법을 특정한다.
   - in, out 명령어로 디바이스와 소통이 가능하다. 
   - 데이터를 디바이스에 보내기 위하여, caller는 레지스터와 port를  지정하고 명령을 시행한다.
   - 이는 특권이 있어서 OS가 디바이스를 제어하고, 그는 디바이스와 바로 소통하는 유일한 entity다.
2. memory-mapped I/O
   - 하드웨어가 디바이스 레지스터를 사용가능하게 된다. 마치 메모리 위치인 것처럼 행동한다.
   - 특정 레지스터에 접근하기위하여 OS는 주소에 load, store를 하게되는데, 하드웨어가 대신 디바이스에 load/store를 하게된다.

특정 한 접근이 더 좋다라는 것은 없고 다 잘 쓰인다.

## Fitting Into The OS: The Device Driver
어떻게 디바이스를 OS가 접근하기 쉽게 할 것인가? 
추상화로 가능하다. 
OS의 한 부분인 디바이스 드라이버가 그를 가능케한다. 

시스템에서 계층이 나눠져, 최대한 윗 단계에서는 아랫 단계의 구체성을 잊게한다. 
- 그러나 이는 굉장히 좋은 기능이나, 좀 구체적인 기능을 사용되지 않게 한다. 

이 디바이스 드라이버는 굉장히 많이 사용되어서 70% 가까이 되는 OS code가 디바이스 드라이버에서 발견된다. 
많이 사용되지 않는 코드도 있고 버그를 발생하는 코드가 많긴 하지만..

## Case Study: A Simple IDE Disk Driver
간단한 인터페이스를 제공한다. control, command block, status, error가 그것이다. 
이 레지스터는 I/O 명령어를 통하여 사용 가능하다. 

