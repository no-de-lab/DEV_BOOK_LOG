분산 시스템은 세상을 바꾸었다. 복잡한 서비스는 여러 머신들의 협동으로 만들어졌다. 

그러나 분산 시스템은 실패를 어떻게 처리하느냐를 고민해야한다. 
시스템의 오류를 client가 모르게 한다. 
해당 머신이 실패하더라도 시스템은 바로 실패하지않게 되는 것이다. 

- 시스템의 성능도 중요하다. 어떻게 메세지 수를 줄이고 커뮤니케이션도 효율적으로 할지, 
- 보안도 중요하다. 
- 소통도 중요하다. 어떻게 머신들이 소통할지? 

## 1. Communication Basics
기본적으로 소통은 믿을만하지는 않다. 종종 패킷을 잃어버리거나 손상된다. 그는 
- bit flipped
- network link, packet damaged
- network cable 손상 등으로 발생한다.

그러나 그보다 더 근본적으로는 네트워크 스위치나 라우터에서 버퍼링이 부족하기 때문이다. 
패킷이 라우터의 메모리에 도착했으나 메모리가 모든 패킷 저장할 수 없다면? 그냥 패킷을 버려버린다.

## 2. Unreliable Communication layers
그런데 그걸 굳이 해결하려고 하지 않아도 된다. 그러지 않아도 몇몇개기 때문에 굳이 해결하지 않는게 유용할수도 있다. 
- 대표적 예시는 UDP
- socket api로 소통 엔드포인트를 구성하고
- 패킷 로스가 생겨도 보내는 이는 알지 못한다. 

그래도, checksum을 이용해서 훼손은 파악한다. 

## 3. Reliable Communication Layers
그러나, 더 믿을 만한 소통이 필요할 때
msg를 상대가 받은지 아닌지 ack를 통해 알 수 있고, 만약 ack를 못 받았다면 sender가 타이머를 두어서 그 시간내에 들어오지 않았다면 다시 packet을 보낸다.

그러나 여기서 문제는, ack를 보냈음에도 못 받은 경우다. receiver 입장에선 한번만 받고싶었는데 메세지를 두번 이상 받을수도 있다. 

이를 receiver가 처리하기위해서는
- sender msg를 식별할 방법이 있어야한다.
- unique ID를 둘 수도 있으나 이는 비싸다
- sequence counter를 sender, receiver 각각 가지고 서로의 값을 비교한다. 

## 4. Communication Abstractions
분산 시스템을 만들 때, 소통 추상화는 어찌 이루나? 
그 한 가지 방법으로는 OS 추상화 방법이 있다. 큰 가상의 주소공간을 머신들이 공유하게끔 하는 것. (DSM)

- 멀티스레드처럼 보이지만 다른 머신들이다. 
- 가상메모리를 다룰 때, 
  - 로컬에 원하는 데이터가 있을 수도 있고
  - 다른 디스크에 있을 수도 있다. 이 때 Page fault가 일어나게 된다. 
    - 이 때는 다른 머신의 데이터를 가져와서 페이지 테이블에 올리고 실행한다. 
    - 그런데 문제가 있다. fail이 일어나면 포인터가 가리키는 곳에 데이터가 없고 부분 데이터를 사용할 수 없게 될 것이다. 
    - 또한 성능 문제도 있다. remote 머신으로부터 데이터를 가져와야하기 때문이다. 
## 5. RPC
OS 추상화가 아닌, 프로그래밍 언어 자체에서 추상화를 하는 것이 더 낫다는 판단 하에, RPC라는 것이 생겨났다. 
이는 프로세스를 최대한 간단하게 하는 것이다. 

- 클라이언트는 그냥 call 하면 리턴값을 받고
- server는 몇가지 클라이언트를 위한 루틴을 만들어준다. 
- RPC가 나머지를 다 하게 되는데, 
  - stub
  - runtime library가 그것이다. 

### Stub Generator
이는 패킹의 고통을 없애고 자동화하고 코드를 최적화한다. 
서버가 export하고자하는 콜셋만 구성하면 클라이언트에 보낼 수 있다. 

- 클라이언트는 스텁을 만들어서 RPC 서비스에 연결한다. 클라이언트에게 이 스텁은 그저 함수처럼 보인다.
  - 이 스텁은 
  - 메세지 버퍼 생성
  - 버퍼에 필요한 정보를 매핑 (serialization, marshaling이라 부른다.)
  - RPC 서버에 메세지를 보낸다.
  - 기다린다
  - 리턴 코드를 풀어낸다.
  - 호출자에 리턴한다.
- 서버는
  - 메세지를 풀고 (unmarshaling, deserialization)
  - 실제 RPC 함수를 호출한다.
  - 리턴값을 패키지하고
  - 보낸다.
- 이 때 몇가지 고려할 사항이 있다.
  - 하나는 복잡한 매개변수다. 
    - RPC 패키지는 이 매개변수의 포인터를 번역하여 적절히 행동한다.
  - 다른 하나는 동시성 서버를 구축하는 일이다. 
    - 간단하게 loop code를 작성할수도 있지만 이 경우 비효율적이다. 자원낭비가 될 것이다. 계속 서버가 기다릴테니 말이다.
    - 그래서 스레드 풀이라는 것을 사용해, 메세지가 도착하면 워커 스레드 중 하나에 보내져서 일하게 된다. 

### Run-time Library
성능과 신뢰성 이슈에 대한 일을 한다. 
- 어떻게 먼 머신에게도 서비스가 가능할까? 
  - naming을 사용해, hostname, port number를 이용한다. 
  - 패킷 라우트 매커니즘을 제공한다.
- 전송 프로토콜도 사용
  - UDP로 효율적인 통신

### 그 외
- 너무 오랜 시간동안 기다리게 하면 retry
  - ack를 명시적으로 보낸다. 
- 매개변수가 커서 그를 fragmentation, 받는 이가 그를 reassemble도 한다.
- 엔디안 체크
- 비동기 추가