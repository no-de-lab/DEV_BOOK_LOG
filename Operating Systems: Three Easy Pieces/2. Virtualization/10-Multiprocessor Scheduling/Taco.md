많은 곳에서 멀티 프로세서 시스템이 사용되고 있다. 멀티코어 프로세스가 나오게되면서, single cpu보다 훨씬 빠른 환경을 제공하게 되었다. 

그러나, 기존 프로그램에 적용하기는 어렵다. 기존 프로그램이 한개의 프로세서에 맞게 만들어졌었기 때문이다. 
어플리케이션 뿐 아니라, 멀티프로세서 스케줄링하는 방법도 고민해야한다. 

## Multiprocessor Architecture
멀티 프로세서 스케줄링을 둘러싼 새로운 문제를 이해하기 위해서, 데이터를 어떻게 공유하는지, 하드웨어 캐시는 어떠한지를 알아보며 근본적으로 single cpu와 multi cpu 간의 차이를 알아야한다. 

- 싱글 
  - 하드웨어 캐시에 계층이 있다. 
  - 캐시를 이용하여 자주 사용하는 데이터를 빠르게 접근 가능하다.
  - 캐시의 지역성에는 임시/공간 지역성이 있는데, 임시는 빠른 시간 내에 다시 접근하는, 공간은 어떤 주소 주위의 데이터도 접근될 가능성이 있는 것을 뜻한다. 
  - 이 지역성을 통해 어떤 데이터를 캐싱할지 결정할 수 있다. 
  - 그렇다면 멀티 프로세서는 여러cpu로 하나의 시스템과 메모리에 어떻게 접근할 것인가? 
- multi
  - cache coherence가 발생 가능하다. write가 한 cpu에서 발생했지만 업데이트가 되지 않아 다른 cpu에서는 업데이트 이전의 데이터를 가져간다. 
  - 이는 하드웨어가 메모리 액세스를 모니터링해야한다. 
  - 이를 버스 snooping이라 하는데, 각 캐시가 메모리에 집중하여, 변경이 있을시 바꾸는 것이다.

## 동기화 
프로그램 또한 캐시처럼 동시성을 신경써야한다. 

공유 데이터에 접근할 때 상호 배체가 정확성을 보장해야한다. lock같은 것들이 그것이다. 

그러나 락 또한, 성능 문제가 있다. 특히 cpu 개수가 증가하면 동기화접근 속도가 감소한다.

## 캐시 친화
여러 CPU가 있는 상태에서, 매번 프로그램이 다른 cpu에서 돌아가게된다면, 분명 속도가 느릴것이다. 
캐시를 cpu에 붙여놓으면, 다음번에 실행할 때 속도가 더 빨라질 것이다. 따라서 가능하다면 프로세스는 같은 cpu에 지속해서 접근해야한다. 

## 싱글 큐 스케줄링
멀티프로세서 시스템에서, 가장 간단하게 시스템을 구축하는 방법은 모든 프로그램을 싱글 큐에 집어넣는 것이다.
이를 sqms라 한다. 이는 간단하다. 왜냐면 다음에 작동할 최선의 작업을 결정하고 하나 이상의 cpu에서 이를 돌리면 되기 때문이다. 

그러나, 분명한 단점은 확장성이 없다는 것이다. 
다양한 cpu에서 스케줄러가 잘 돌아가게 하기 위해, locking이라는 것을 지원하는데, 이는 성능을 몹시 낮출수있다. 프로세스가 많아질수록 락이 더 많아지고, 오버헤드가 커진다. 

또한 캐시 친화성이 부족하다. 여러 cpu에서 여러 프로세스가 돌아가면 매번 다른 프로세스가 cpu에서 돌기 때문에 캐시가 생길 수가 없는데, 이를 해결하기위하여 한 cpu에 특정 프로세스를 지정해볼수도 있지만, 이는 복잡하다. 

## multi-queue 스케줄링
이 싱글큐의 문제점으로, 몇몇 시스템에서는 멀티 큐를 적용한다. 하나당 cpu 하나를 의미한다. 이 스케줄링에서는 여러 큐에 프로세스들이 지정되어 들어가있고, OS가 어떤 프로세스를 해당 큐에 넣을지 결정한다. 
이 스케줄링은 확장성이 있다. cpu 수가 늘어나면 큐 수도 늘어나고, 락과 캐시가 중요하지가 않다. 게다가. 본질적으로 캐시 친화성을 제공한다.

그러나, load imbalance 문제가 있다. 
만약 어떤 cpu에 있던 큐의 프로세스가 모두 종료되었는데, 다른 cpu의 큐는 종료가 되지않았다면? 비효율이다. 

가장 확실한 방법은 작업들을 옮기는 것이다.
만약 하나의 프로세스가 남아있는데 옮겨가는 거라면, 지속적으로 프로세스를 바꾸어간다. 어떻게 시스템이 옮겨가는 것을 결정할까?

큐에 프로세스가 얼마 남지 않으면, 다른 큐를 확인해보고 너무 많으면 거기서 프로세스를 가져오게된다. 
물론, 너무 많이 주위를 둘러보게 되면, 이는 또한 오버헤드다. 너무 주위를 둘러보지않으면, load imbalance가 생기기도 한다. 

