기존에는 프로세스 각각의 전체 주소 공간을 메모리에 집어넣었기 때문에, OS는 base and bounds register로 서로 다른 물리적 메모리 공간 배분이 가능했다. 

그러나, stack과 heap 사이의 노는 공간이 있을 수 있음을 알아야한다. 
이는 낭비다. 또한 전체 주소공간이 메모리에 맞지 않을 때, 프로그램을 돌리기도 쉽지않다. 

## Segmentation: Generalized Base/Bounds
이 문제를 해결하기위해 세그멘테이션 등장! 
한 쌍의 base, bounds만 가지는 것이 아니라, 주소 공간의 모든 세그먼트(code, stack, heap)에 base, bounds를 두는것이 메인 아이디어!

세그먼트는 그저 주소 공간의 한 연속적인 부분이고, 세그멘테이션은 OS로 하여금, code, stack, heap 중 하나를 다른 물리적 메모리에 놓아 물리적 메모리를 사용되지 않는 가상 메모리로 채우지 못하게 한다. 
각 세그먼트는 물리적 공간 베이스와, 사이즈를 가지고 있다. 이 경우 bounds가 사이즈라 할 수 있다. 

만약 사이즈를 벗어나면 trap을 발생시킨다. -> segmentation violation, segmentation fault 발생한다. 

## Which Segment are we referring to? 
그런데 어떻 세그먼트를 참조하고 있는지 어떻게 알게되는 걸까? 

하나의 흔한 접근으로는, (명백한 접근이라고도 불리는데) 주소공간을 세그먼트로 자르는 것이다. 
두개의 bit가 이 세개의 세그먼트를 구분할 수 있기 때문에, 총 14비트 중 2개는 세그먼트를 알리고, 나머지 12비트는 offset을 알린다. 
- code -> 00 비트
- heap -> 01 비트

또 다른 접근으로는, 주소가 어떻게 생성되었는지 알아차려서 참조부분을 결정한다. 
예를들면, program counter로부터 주소가 생성되었다면 code, stack이나 베이스 포인터로부터 주소가 발생ㅊ했으면 스택, 아니면 힙이라는 식이다. 

## What abount the Stack? 
stack 빼고 heap과 code만 이야기했는데, 스택은 힙이나 코드와는 반대 방향으로 데이터를 쌓는다. 
그렇기 때문에, 하드웨어는 조금 다르게 가상 메모리를 변환해야한다. 
offset이 3KB일 때, 세그먼트 맥시멈 사이즈를 여기서 빼야 거꾸로 쌓을 수 잇다. 즉, 이 경우 3-4 = -1이 오프셋이다. 

## 공유에 대한 지원
효율성을 위해 다소간 하드웨어 지원이 필요하다. 
프로텍션 비트를 하나 두어서, read-only의 경우, 다른 프로세스 간에 공유가 가능하게끔 한다. 
이와 함께 알고리듬도 바뀌어야 하는데, 이 경우 bound 내에 가상 메모리가 위치하는지와 함께 특정 접근이 허용되는지도 체크해야한다.

## Fine-grained vs Coarse-grained Segmentation
code, heap, stack으로 세그먼트 구분짓는 것은 coarse하다. 
이보다 이전에는, 조금 더 촘촘히 segement를 구분지어서 OS가 어떤 세그먼트를 사용하고 아닌지 그래서 메인메모리를 더 잘 이용할지를 결정할 수 있을 것이라 믿엇다. 
실제로 이 fine-grained는 조금 더 많은 수의 세그먼트가 있고, 세그먼트 테이블이 있었다. 

## OS Support
사용되지 않는 세그먼트들이 물리적 메모리에 할당되지 않아서, 주소 공간을 더 잘 쓸 수가 있다. 

그러나, OS가 컨텍스트 스위치 시에 무엇을 해야하는가? 세그먼트 레지스터가 세이브되어야한다. 프로세스가 다시 돌기 전에 확실히 이 레지스터가 설정되어야한다. 

더불어, OS가 세그먼트가 커지면 어떻게 해야하는지도 문제다. 시스템 콜을 날리면 물리적 메모리를 더 나누어주긴 하지만, 없으면 못 나눠준다. 

또한 물리적 메모리 내의 free space를 관리하는 것도 쉽지않다. 외부화가 일어나기 때문이다. 
우리는 각각의 주소공간이 같은 사이즈일것이라고 가정했었지만, 세그멘테이션은 아니다. 각기 다른 사이즈를 가지고 있다. 
그래서 이를 compact하게 만들수도 있지만, 이 컴팩트는 비용이 비싸다. 왜냐면 기존에 위치한 프로세스를 옮겨야하고 그동안 프로세스가 운영되지 못한다. 

더 간단한 접근은 free-list 관리를 통하여, 분배를 할 때 많은 범위를 남겨두게끔 하는 것이다. best-fit, worst-fit, buddy algorithm같은 것들도 있다. 

그러나 그럼에도 불구하고 외부화는 일어날 수밖에 없다. 

