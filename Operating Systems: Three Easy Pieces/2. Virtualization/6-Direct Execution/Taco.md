CPU를 가상화하기위해서, 결국엔 OS는 다소간 물리적 CPU를 공유해야한다. 즉 시분할을 해야한다. 

그런데, 이를 하는 데 몇가지 해결해야할 과제가 있다. 
하나는, 과도한 오버헤드 없이 가상화를 이루어낼 방법이 무엇이냐고, 다른 하나는 CPU에 있어 제어권을 가졌을 동안 어떻게 효율적으로 프로세스를 실행하느냐다.

결국, OS에 있어서, cpu 제어를 가진 동안 어떻게 성능을 최대로 이끌 것이냐가 메인 고민이라 할 수 있다.

### 기본적 방법: Limited Direct Execution
- CPU에 직접적으로 프로그램을 실행한다. 그런데 이 방식에는 두 가지 문제가 있다. 
  - 어떻게 OS가 우리가 원하지 않는 일을 하지 않는다고 확신할 수 있는지?
  - 어떻게 OS가 어떤 프로세스를 정지하고 다른 프로세스로 이동할 수 있는지? 

- CPU에 직접 실행하여 빠르다는 장점은 있다. 그런데 만약 어떤 프로세스가 제한된 작업을 요청할 때는? 
  - 간단한 방법으로는 그냥 하게 두는 것이다. 그렇지만, 그럴 경우 다른 많은 시스템의 설계를 방해한다. 
  - 그러므로, user mode라는 프로세서 모드가 있다. 그가 하는 일은 제한된다. 프로세스는 I/O 요청을 할 수 없다. 
  - user mode 반대는 kernel mode가 있는데, OS가 작동하고 있는 것이다. 이는 코드가 하고싶은 것을 할 수 있다.
- 그러나, 여전히 문제가 있다. user process가 자격이 있는 작업을 하고싶어한다면 어떻게 해야하는지: 이를 위해 시스템 콜이라는 것을 작동하게 한다. 
  - 이는 kernel이 중요 기능을 유저 프로그램에 조금 노출시키는 것이다. 
  - 이를 시행하기위해서, trap이라는 것을 프로그램에서 실행한다. 그렇게 되면 kernel mode로 권한 레벨이 올라가고, 커널에 명령어가 올라간다. 
    - 끝나면, OS return-from-trap이라는 명령어를 호출한다. 
    - 이 경우 하드웨어는 호출자의 레지스터를 잘 저장해야만 한다. 
- 그런데, 트랩은 어떤 코드를 실행해야하는지 어떻게 아는가? 트랩 테이블을 통하여 안다. 커널은 부팅시 트랩테이블을 만드는데, 하드웨어가 이를 알게끔 한다.
- 정확한 시스템 콜을 특정하기 위해, 시스템 콜 번호가 주로 주어진다. 
- Limited direct execution protocol을 통해서, 
  - 첫 단계에서는 커널이 부트 타임에 트랩테이블을 시작하고, cpu가 다음 사용을 위해 위치를 기억한다. 이는 privileged instruction을 통하여 가능하다. 
  - 프로세스가 돌고 있는 동안에는, 커널이 return -from-trap 명령어를 실행하기 전에 미리 메모리를 할당하는 등의 준비를 해놓고, 프로세스 실행을 시작한다. 이는 cpu가 유저 모드로 바뀌게 한다.
  
### 문제 해결: 프로세스 간의 스위칭
- OS는 하나의 프로세스에서 다른 프로세스로 넘겨가야한다. 이는 조금 까다롭다. 
  - CPU에서 프로세스가 돌고있는 거라면, 사실 OS는 돌고있지 않다는 뜻이된다. OS가 돌지 않으면, 아무것도 하지 못한다. 그렇다면 어떻게 제어권을 가져올 수 있을까? 
  - 과거에 시스템이 채택했던 방법은 cooperative 접근이다. 이는 OS가 합리적으로 잘 행동한다고 믿는 것이다. 너무 긴 시간동안 CPU를 가지고 있는 프로세스가 주기적으로 그를 포기할 거라 믿는 것이다. 
  - 대부분의 프로세스는 시스템 콜 혹은 트랩을 통하여 돌려주는데, 이는 어쨌건 협력적이기는 하다. 그렇지만 만약 프로세스가 무한 루프에 빠지게 되면 어떻게 할것인가? 원래같았으면 그냥 리부트해야한다. 
- 그래서, OS는 그래서 타이머 인터럽트를 사용한다. 타이머는 수 milliseconds 마다 활동한다. 이 때 os는 cpu 제어권을 가져오게 된다. 그 이후 현 프로세스를 종료하고, 새로운 것을 시작한다. 이 타이머를 부트할 때 시작하고, 또한 priviliged operation이다.

## 맥락을 저장하고 되돌리기
이렇게 OS가 제어권을 가져오면, 현 프로세스를 계속 돌릴지 아니면 스위칭할지 결정해야한다. 이는 스케줄러에 따라 결정된다. 

스위치하기로 결정되었다면, os는 context switch라는 것을 실행한다.
- OS가 할 일은, 몇몇의 PC 레지스터 값을 저장해주고
- 실행할 프로세스를 restore하는 것이다. 
- OS는 이를 통애 언제 return-from-trap할지를 확실히 할 수 있다. 
- 
