CPU를 가상화하기위해서, 결국엔 OS는 다소간 물리적 CPU를 공유해야한다. 즉 시분할을 해야한다. 

그런데, 이를 하는 데 몇가지 해결해야할 과제가 있다. 
하나는, 과도한 오버헤드 없이 가상화를 이루어낼 방법이 무엇이냐고, 다른 하나는 CPU에 있어 제어권을 가졌을 동안 어떻게 효율적으로 프로세스를 실행하느냐다.

결국, OS에 있어서, cpu 제어를 가진 동안 어떻게 성능을 최대로 이끌 것이냐가 메인 고민이라 할 수 있다.

### 기본적 방법: Limited Direct Execution
- CPU에 직접적으로 프로그램을 실행한다. 그런데 이 방식에는 두 가지 문제가 있다. 
  - 어떻게 OS가 우리가 원하지 않는 일을 하지 않는다고 확신할 수 있는지?
  - 어떻게 OS가 어떤 프로세스를 정지하고 다른 프로세스로 이동할 수 있는지? 
- CPU에 직접 실행하여 빠르다는 장점은 있다. 그런데 만약 어떤 프로세스가 제한된 작업을 요청할 때는? 
  - 간단한 방법으로는 그냥 하게 두는 것이다. 그렇지만, 그럴 경우 다른 많은 시스템의 설계를 방해한다. 
  - 그러므로, user mode라는 프로세서 모드가 있다. 그가 하는 일은 제한된다. 프로세스는 I/O 요청을 할 수 없다. 
  - user mode 반대는 kernel mode가 있는데, OS가 작동하고 있는 것이다. 이는 코드가 하고싶은 것을 할 수 있다.
- 그러나, 여전히 문제가 있다. user process가 자격이 있는 작업을 하고싶어한다면 어떻게 해야하는지: 이를 위해 시스템 콜이라는 것을 작동하게 한다. 
  - 이는 kernel이 중요 기능을 유저 프로그램에 조금 노출시키는 것이다. 
  - 이를 시행하기위해서, trap이라는 것을 프로그램에서 실행한다. 그렇게 되면 kernel mode로 권한 레벨이 올라가고, 커널에 명령어가 올라간다. 
    - 끝나면, OS return-from-trap이라는 명령어를 호출한다. 
    - 이 경우 하드웨어는 호출자의 레지스터를 잘 저장해야만 한다. 
- 그런데, 트랩은 어떤 코드를 실행해야하는지 어떻게 아는가? 트랩 테이블을 통하여 안다. 커널은 부팅시 트랩테이블을 만드는데, 하드웨어가 이를 알게끔 한다.