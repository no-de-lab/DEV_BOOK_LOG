# The Process
프로세스는 실행 중인 프로그램이다.


OS의 역할 중 물리적 리소스인 CPU를 가상화 한다. 
한 프로그램을 실행했다 멈추고, 다음 프로그램을 실행했다 멈추는 식으로 여러 프로그램이 동시에 실행되는 착각을 준다. 
이러한 기술을 _time-sharing_ 이라고 한다. 
이것에는 잠재적인 비용이 있는데, 성능이다. 
실행하는 프로그램이 늘어 날 수록, CPU 공간을 차지하기에 각 프로세스가 더 느리게 실행된다. 

CPU 가상화를 위해 OS는 low-level machinery(메커니즘) 와 high-level intelligence 둘 다 필요로 한다.
메커니즘은 필요한 기능을 구현하는 낮은 수준의 메서드 또는 프로토콜을 말하며, 이를 로우레벨 기계 메커니즘(low-level machinery mechanisms)이라고 부른다.

> 예를 들어 다른 브라우저를 보기위해서 키보드나 마우스 클릭으로 이동하는데 이렇게 기계에 인풋 하는것도 저수준 기계식 메커니즘이라고 생각하면 될까? 
  [기계 메커니즘](https://cadofrainbow.tistory.com/82)

- low-level machinery(메커니즘)
  - time-sharing mechanism
    context switch - OS가 cpu에서 실행하는 프로그램을 멈추고 다른 프로그램을 실행할 수 있도록 한다. 


이러한 메커니즘 외에도 OS에는 정책이라는 형태의 인텔리전스(high-level intelligence)가 있다. 
정책은 OS 내에서 어떤 종류의 결정을 내리기 위한 알고리즘입니다. 


## The Abstraction: A Process

프로세스를 구성하는 요소를 이해하려면 machine state, 머신 상태를 이해해야한다. 
머신 상태의 중요 요소
- memory
  프로그램을 실행하는데 필요한 명령어와 데이터는 메모리에 있다. 메모리(주소공간)는 프로세스의 일부이다.
- 레지스터(register)
  CPU가 프로그램의 실행 흐름을 제어하거나 상태를 저장하기 위해 사용된다.xx
  - 프로그램 카운터(PC, Program Counter) : 다음에 실행할 명령어의 주소 저장
  - instruction pointer: CPU가 처리해야하는 명령어의 '주소'를 나타내는 레지스터 
  - stack pointer: 스택 영역에 함수를 구분하기 위해 생성되는 공간으로서 스택은 Parameters, Return Address, Local variables를 포함하고 있으며, 함수 호출 시 생성되고 함수가 종료되면서 소멸

프로그램은 영구 저장 장치에도 접근한다. 이러한 입출력 정보에는 프로세스가 현재 열려 있는 파일 목록이 포함될 수 있다. 


[레지스터](https://plummmm.tistory.com/113)
[컴퓨터구조](https://dheldh77.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0Register)

## Process API
Process API란 OS가 Application에게 제공하는 Interface이다.

- Create: 프로그램을 실행하기 위한 새 프로세스를 생성 (셸 명령어 입력, 애플리케이션 실행)
- Destroy: 프로그램 강제종료
- Wait: 프로그램 대기 (프로세스 실행이 중지될 때까지 기다리는 것이 유용할 때가 있을때 제공)
- Miscellaneous Control: 프로세스를 일시 중단, 다시 시작 등 기타 제어
- Status: 프로세스에 대한 일부 상태 정보를 얻을 수 있는 인터페이스

## Process Creation
프로세스 생성은 실제로 어떻게 이루어 지는가? 

- Load
프로그램 실행을 위해 필요한 코드와 데이터를 메모리, 주소공간에 불러온다.
프로그램은 처음에 일종의 실행 파일 형식으로 disk(SSD)에 저장되어 있다. 
로딩하는 과정에서 OS는 디스크에서 해당 프로그램의 바이트를 읽고 그것을 메모리에 어딘가에 배치한다.
초기 OS는 로딩 프로세스를 프로그램 실행 전에 한번에 수행되었으나, 현재는 필요할 때만 수행한다. (paging, swapping)

- Allocation(메모리 할당)

`스택(stack)`
프로그램은 실행되기 전에 어느 메모리는 런타임 스택(=스택)에 할당되어야 한다.
OS는 스택을 호출(메모리 할당)하고 프로세스를 제공한다.

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 스택 영역은 함수의 호출과 함께 할당되며, 함수가 호출되면 스택에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소값, 함수에서 선언된 지역 변수 등이 저장된다.

> main() 함수에 대한 매개변수, 즉 argc와 argv 배열을 채운다.

`힙(stack)`
OS는 프로그램의 힙을 위해 일부 메모리를 할당할 수도 있다. 힙은 요청된 동적 할당 데이터에 사용된다. 힙은 링크드 리스트, 해시 테이블, 트리 등 데이터 구조에 필요하다.

> malloc(): 메모리 동적할당
> free(): 메모리 해제  (malloc로 할당)
  힙 메모리에 공간은 프로그램이 종료될 때까지 존재하기에 할당 후 해제하지 않으면 메모리 사용량만 계속해서 증가하기에 마지막에 꼭 메모리 해제를 해야한다. 그렇지 않으면 메모리를 낭비하여 서응 부하를 일으키는 `메모리 누수 현상`이 발생한다.

- Initialization(I/O 설정)
OS는 입출력(I/O)과 관련된 몇 가지 다른 초기화 작업도 수행한다.
UNIX 시스템에서 각 프로세스에는 기본적으로 표준 입력, 출력 및 오류에 대한 3개의 file descriptor를 가지도록 초기화된다.

- Entry point(프로그램 실행단계)
main()에서 프로그램을 실행하는 것이다. main() 루틴으로 이동하면, OS는 CPU의 제어권을 새로 생성된 프로세스로 이전하여 프로그램이 실행을 시작한다.

## Process States
모든 프로세스는 세 가지의 상태(state) 중 반드시 하나를 가진다.

세 가지의 상태(state)
  - Running: 프로세스가 프로세서에 의해 실행중인 상태
  - Ready: 프로세스가 실행될 준비는 되어 있으나, 어떤 이유로 인해 OS가 아직 CPU를 넘겨주지 않은 상태
  - Blocked: 특정 이벤트가 끝나기 전까지는 실행될 수 없는 종류의 작업을 하고 있는 상태(디스크로부터의 I/O 요청이 대표적)

프로세스는 OS에 따라 상태를 전환할 수 있다.
- schedule: 프로세스가 ready 상태에서 running 상태로 전환되는 것을 의미
- deschedule: 프로세스가 running 상태에서 ready 상태로 전환되는 것을 의미

프로세스가 blocked 상태가 되면, OS는 어떤 이벤트가 발생할 때까지 blocked 상태를 유지한다가 I/O가 완료된 시점에서 프로세스는 준비 상태로 전환된다.
> 디스크에서 읽거나 네트워크에서 패킷을 기다리는 동안 프로세스는 blocked 상태

프로세스의 실행 결정 유형은 OS scheduler에 의해 이루어 진다. (나중에 다룰 예정)

## Data Structures
OS도 프로그램이므로, 다른 프로그램과 마찬가지로 다양한 정보들을 추적하기 위한 데이터 구조를 가지고 있다.

`Process list`는 OS 중요한 데이터 구조의 첫 번째이다. 
프로세스에 대한 정보를 저장하는 개별 구조를 `프로세스 제어 블록(PCB)`이라고 한다.
=> 시스템 내 모든 프로세스에 대한 정보를 PCB 항목에서 찾을 수 있다. 

> 관련되는 Context Switch는 뒤 챕터에서 자세히 다룸

[PCB](https://dev-mystory.tistory.com/119)