segmentation으로 가상 메모리를 서로 다른 크기로 나누는 것의 문제는 공간이 다 fragmented된다는 것이었다. 
그래서, 고정된 사이즈로 나누는 시도가 있다: Paging이다. 

이 페이징은 가상 메모리, 물리메모리 모두 다 같은 사이즈의 slot으로 나눈다. 

그렇다면 어떻게 이를 가상화할까?

## A simple example and overview
### paging의 가장 큰 개선: 유연성
- 프로세스가 주소 공간을 어떻게 쓰든 관계 없는 추상화를 이룰 수 있다.
### 심플함
- OS가 물리 메모리에 64바이트의 주소 공간을 놓으려고 한다면, 그냥 네개의 free page만 찾아내면 된다. 
- OS는 모든 free page에 free list를 가지고 있고, 거기서 네개의 free page를 가져오는 것이다. 

### page table
- 가상 페이지 주소 공간이가 물리 메모리의 어디에 위치하는지 기록하기위하여 페이지 테이블이 있는데, 이는 프로세스 당 생성한다. 
- 이는 주소 변환 정보를 저장한다. 가상메모리에서 물리 메모리의 어디에 매핑되는지가 들어있다. 
- OS는 각기 다른 프로세스별 페이지 테이블을 바라보아야한다. 
- 가상 주소를 가상 페이지 번호와 offset으로 나눈다. 
- 주소 공간의 페이지 사이즈가 비율로 얼마나 차지하는지 확인한 뒤, 가장 페이지 숫자를 결정한다, ex.1/4이면 2비트
- 그러고 이를 물리 프레임 번호로 바꾼다.

## 어디에 페이지 테이블이 저장되는가? 
- 너무도 큰 공간을 차지해버릴 수 잇다. 
- 메모리 어딘가에 저장한다.

## 페이지 테이블에는 무엇이 있나요
- 그저 가상주소와 물리주소를 매핑하는 자료구조. 가장 간단한 형태는 선형페이지 테이블이다. 
- OS가 배열을 인덱싱하여, 페이지 테이블 엔트리를 찾아보고 결국 물리프레임넘버를 찾아낸다. 
- 각 엔트리에는, 특정 메모리 매핑이 valid한지 알려주는 valid bitrk dlTek. 