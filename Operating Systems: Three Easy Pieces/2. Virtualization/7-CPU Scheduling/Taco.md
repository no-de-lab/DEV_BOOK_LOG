어떻게 OS가 스케줄링을 할 것인가.
## Workload
workload에 대한 결정이 스케줄링 정책을 만드는 데 중요하다. 더 workload를 잘 알수록, 더욱 더 정책이 정교해진다.

1. 각 job은 같은 시간동안 돈다
2. 모든 job은 동시에 도착한다.
3. 일단 시작하면, 각 job은 완료를 위해 돈다.
4. 모든 job은 cpu만을 사용한다. 즉 i/o를 하지 않는다.
5. 런타임이 알려져있다.

라는 workload라는 가정을 하고 스케줄링을 구성한다.
## Scheduling Metrics
workload 가정을 만들어내는 것 이상으로, 우리는 하나가 더 필요한데, 그는 스케줄링 메트릭스다. 이는 무엇인가를 추정할 때 사용하는 것이다. 

우선은 trurnaround time으로 간소화한다. 
이는 프로세스가 도착해서 끝나는 시간까지를 의미한다. 

우리는 모든 job이 동시에 도착한다는 가정을 하게 되므로, 도착하는 시간을 0으로 설정한다. 
이 턴어라운드 시간은 성능 메트릭이다. 
다른 메트릭은 공정함이다. 이 성능과 공정함은 가끔은 경합한다. 

## FIFO
먼저 온 순서대로 실행되는 것이다. 실행하기가 쉽고 간단하다. 
공정하다 생각할 수는 있지만, 온 순서대로 실행되어서, 먼저 온 프로세스 시간이 너무 길면 뒤의 짧은 실헹시간을 가지는 프로세스가 오래 기다리게 된다. 
이는 convoy effect라고 한다. 

## Shortest Job First
FIFO를 보완하기 위하여, 간단하게 접근해본다. 
가장 짧은 것 순으로 실행한다. 
사실, 동시에 모든 job들이 도착한다고 가정해본다면, 이는 최적의 스케줄링 알고리즘이다. 

그러나, 다른 job들이 늦게 도착했는데, 먼저 도착한 프로세스 시간이 너무 길어도 결국 FIFO와 같다. 

## Shortest Time-to-Completion First
이는 선점의 개념을 추가한 것이다. 