## 어떻게 프로세스를 만들고 제어하는가
어떤 인터페이스가 있는지에 대하여 코드적으로 설명한다.

### fork()와 System Call
- fork() 시스템은 새로운 프로세스를 만드는 데 사용된다. 
- PID로 프로세스를 구분하여 프로세스를 체크해보았을 때, fork를 하게 되면, 호출한 프로세스가 복제가 된다.
- 그리고 그 복제가 된 프로세스를 child, 복제를 한 프로세스를 parent라고 할 때, child가 정확한 copy는 아니다. 
- 그만의 레지스터, PC, 주소 공간이 생긴다. 
- 그래서 PID도 서로 다르다. 
- CPU가 하나라는 가정 하에는, 프로세스 간의 순서가 결정된 상태가 아니다. CPU 스케줄러가 이를 결정하는데, 멀티 스레드 프로그램에서 이 결정되지 않은 점은 동시성 문제를 일으킬 수 있다.

### wait() 시스템콜
wait을 하면 determistic하게 결과를 예측 가능하다.
비록 부모 프로세스가 먼저 실행되더라도, 자식 프로세스를 기다리게 되기 때문이다. (wait()을 사용하면)

### exec() 시스템 콜
호출한 프로그램과 다른 실행 프로그램을 필요로 할 때 유용하다. 
exec()으로 자식 프로세스에 새로운 프로그램을 덮어 씌울 수 있다.

굳이 왜 fork와 exec을 나누는지에 대하여 의문을 품을 수도 있다.
shell로 하여금 쉽게 많은 일을 하게 도와준다. 
- 리다이렉션: 입력에 따른 출력의 방향을 바꾸어준다. 
- pipe도 이와 비슷하게 실행되는데, pipe()라는 시스템 콜을 통한다.

### 프로세스 조절과 사용자
fork, exec, wait 이외에도 다른 인터페이스가 유닉스 시스템에는 많다.

프로세스에 종료 시그널을 보내기 위한 kill같은 시스템 콜도 있고, 편의를 위하여 keystroke로 시그널을 보낼 수도 있다. 

이러한 시그널 하위 시스템에서는 전체 프로세스 그룹 뿐 아니라 개별 프로세스에도 시그널을 보내기 위한 방법을 제공한다.

그렇다면, 누가 시그널을 프로세스에 보내고 누가 보낼 수 없는가? 
현대 시스템에는 유저라는 개념이 있어서, 자격이 있는 자가 그를 제어할 수 있다. 루트 유저(슈퍼유저)는 그 중에서도 관리자같은 역할이다. 보안을 위해서는, 일반 유저인 편이 나을지도 모른다. 

### 유용한 툴
ps, top, kill 등 프로세스에 명령어 툴은 유용하다. 
또한, CPU meters를 통하여 빠르게 시스템에 로드를 확인할 수 있다. 