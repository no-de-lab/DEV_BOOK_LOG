**Multi-level Feedback Queue (MLFQ)**
- 1962년에 처음으로 발표된 MLFQ는 현대 시스템에서 발전된 형태로 찾아볼 수 있다. 
- 프로세스가 얼마나 돌아갈지에 대한 정보가 없는 상태로 턴어라운드 타임, response time 모두를 적절히 만족할 스케줄링을 고민한다.

### MLFQ: Basic Rules
- 서로 다른 우선순위를 가지는 queue를 가지고 있다. 
- 이 우선순위를 통하여, 주어진 시간동안 어떤 프로세스를 실행할지를 결정한다. 
- 같은 우선순위를 가지는 프로세스가 한 큐에 있으면, Round-robin 방식으로 운영한다. 
- 그런데, 프로세스별로 우선순위가 항상 일정한 것은 아니다. 
  - 만약 I/O 과정에서 입력을 기다리다가 프로세스가 CPU를 내어주게 되면, MLFQ는 해당 프로세스의 우선순위를 유지한다. 
  - 대신에, 너무 오랜 시간동안 CPU를 가지고 있었던 프로세스가 있다면, 해당 프로세스의 우선순위를 낮춘다. 
  - 이런 방식으로, MLFQ는 꾸준히 프로세스들에 대한 학습을 하게된다. 
### How To Change Priority
- 프로세스가 시스템에 들어오면, 가장 높은 우선순위를 가진다.
- 프로세스가 모든 시분할을 사용하게 되면, 우선순위가 낮아진다. 
- 프로세스가 시분할이 끝나기 전에 CPU를 포기하게 되면, 같은 우선순위를 유지한다. 
- 예시 1: Single Long-Running Job
  - 모든 시분할을 사용한 프로세스가 우선순위가 낮아진다. 
- 예시 2: Along Came A Short Job
  - 일단 짧은 프로세스인지 모르는 상태에서 그것이 짧을 것이라 가정한 뒤에, 높은 우선순위를 준다. 
  - 만약 그것이 짧지 않았다면 점점 우선순위를 낮추게된다. 그렇게 스스로가 batch job임을 스스로 증명한다.
- 예시 3: What About I/O?
  - 만약 많은 I/O작업이 있어서, CPU를 포기하게 된다면, 같은 우선순위를 유지한다. 
- MLFQ의 문제
  - 기아의 문제: 너무 많은 대화형 프로세스가 있을 때, 길게 이어지는 프로세스는 CPU를 할당받지 못하게 될 것이다. 
  - 대화형 프로세스를 짤 때 어떤 이는 딱 I/O 프로세스를 시분할 시간이 끝나기 직전에 시작하고 CPU를 포기하여, 계속 우선순위가 유지되게끔 할 수 있다. (gaming)
  - 프로그램은 시간에 따라 행동을 바꾸는데, 그것을 반영하기 어렵다. 

### The Priority Boost
- 주기적으로 우선순위의 변동을 준다.
  - S정도의 시간이 씉나면, 프로세스들을 위로 끌어올린다. 
  - 이는 기아를 줄이고, 만약 cpu-bound가 대화형으로 행동을 바꿀 때에도, 적절히 반응할 수가 있다. 
- 그런데 S를 어떻게 정의내릴지가 또 문제다. 
  - S 시간을 너무 길게 잡으면 또 기아문제가 발생하고, 너무 짧으면 I/O가 적절한 시간을 부여받지 못하게된다. 
  - 이 S를 voo-doo 상수라고 부른다.

### Better Accounting
- 문제 하나가 더 있다. gaming 문제를 어떻게 방지할까.
  - 이 때는 조금 더 나은 계산방법을 도입하는 것이다. 
  - 각 프로세스별로 주어졌던 시간을 계속 트래킹해서, 그 시간을 다 쓰면 다음 우선순위로 강등된다. 

### Tuning MLFQ and Other Issues
여전히 문제는 있다. 
가장 큰 문제는 어떻게 기준을 세우는지에 관한 것이다. 쉬운 해답은 없으며, 경험만이 이를 만족스럽게 밸런싱할 수 있다. 
- 대부분의 변수들은 시분할 시간을 바꾸는 것을 허용한다. 
- 어떤 스케줄러들은 유저가 좀 적절한 설정을 해주기를 바라기도 한다. 

### Summary
MLFQ는 다양한 레벨의 큐를 두고는, 계속해서 프로세스들 간의 우선순위를 반영한다. 
과거를 통해서 미래의 방향을 설계한다. 

1) 우선순위가 더 높은 것이 실행된다. 
2) 우선순위가 같으면 round-robin으로 실행된다. 
3) 처음 프로세스가 진입하면, 가장 높은 우선순위에 배정된다. 
4) 프로세스가 모든 주어진 시간을 다 사용하면, 우선순위가 강등된다. 
5) 특정 S 시간이 지나면, 모든 시스템의 프로세스를 가장 높은 우선순위로 올려준다. 

이는 프로세스들의 실행을 보고, 계속해서 관리해나간다는 점에서 흥미롭다. 
fair하면서도, 좋은 성능을 낼 수 있다. 

그래서, 많은 시스템에서 이를 사용하고 있다.