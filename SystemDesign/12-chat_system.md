채팅 앱을 설계할 때, 고려해봐야할 문제는 정확히 어떤 류의 앱이냐는 것이다.
인스타그램 Dm이나, 위챗과 같이 1:1인지, 혹은 대규모 그룹의 소통인지를 알아야한다. 

더불어 트래픽 규모나, 중요 기능, 메시지 길이 등도 알아야한다.

어떤 통신 프로토콜을 사용할 것인가도 중요한 문제다.

송신 클라이언트 - 채팅 서비스(서버) - 수신 클라이언트 구조에서 HTTP 프로토콜을 사용한다고 보았을 때, 

송신 클라이언트가 수신 클라이언트에 보내는 것 까지는 keep-alive 헤더를 사용하면 되지만, 수신의 경우에는 서버가 클라이언트로 임의 시점에 메시지를 보내는 데는 쉽게 쓰일 수 없다. 

그래서 서버가 연결을 만드는 것처럼 동작할 수 있게 폴링, 롱 폴링, 웹소켓이 등장했다. 

## 1. 폴링
클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법이다. 
답해줄 메시지가 없으면 서버 자원이 불필요하게 낭비되는 문제가 있다.

## 2. 롱 폴링
폴링이 여러모로 비효율적이라, 롱 폴링이 등장했다. 

클라이언트가 새 메시지 반환 혹은 타임아웃 될 때까지 연결을 유지한다. 
만일 새 메시지를 받으면 기존 연결을 종료하고, 서버에 새 요청을 보내 모든 절차를 다시 시작한다. 

이는 하지만 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다.

또, 서버 입장에서 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다. 그리고 더 큰 문제는 여전히 비효율적이라는 것이다. 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 대마다 주기적으로 서버에 재접속하게된다. 

## 3. 웹 소켓 
서버가 클라이언트에 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다. 

클라이언트가 먼저 웹소켓 연결을 시작한다. 한번 맺어진 연결은 양방향, 항구적이다.

처음에는 HTTP 연결이지만, 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다. 웹소켓은 일반적으로 방화벽이 있는 환경에도 잘 동작한다. 

메세지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있어 설계 뿐 아니라 구현도 단순하고 직관적이다. 유의점이라 하면, 웹소켓 연결은 항구적으로 유지되어야해서 서버 측에서 연결 관리를 효율적으로 해야한다는 것이다.

# 개략적 설계안
- 무상태 서비스: 로그인, 회원가입, 사용자 프로파일 표시 등의 전통적 요청/응답 서비스
- 상태유지 서비스: 채팅 서비스
- 제3자 서비스 연동: 푸시알림
- 규모 확장성:이 서비스가 좀 더 커지면, 규모를 확장도 할 수 있어야한다.
- 데이터 계층: 데이터의 유형과 읽기/쓰기 연산의 패턴을 고려해서, 데이터베이스를 채택해야한다. 
    - 일반 데이터: 안정성을 보장하는 관계형 데이터베이스(다중화, 샤딩 이용해 사용자 프로파일나 설정, 친구 목록과 같은 일반적 데이터를 저장한다.)
    - 채팅 이력: 데이터 양이 엄청나다. 그런데 무작위적 데이터 접근을 할 수도 있다. 이를 해결하기 위해서는 키-값 저장소가 추천된다.
        - 수평적 규모 확장이 쉽다.
        - 데이터 접근 지연시간이 낮다.
        - 관계형 db는 롱테일에 해당하는 부분을 잘 처리하지 못해, 인덱스가 커지면 데이터에 대한 무작위 접근 처리 비용이 늘어난다.
        - 이미 많은 안정적 채팅 시스템이 이를 채택했다. 

- 데이터 모델
    - 1:1 채팅을 위한 메시지 테이블 (msg_id, msg_from, msg_to, content, created_at)
    - group 채팅을 위한 메시지 테이블(channel_id, msg_id, msg_to, content, created_at)

    msg_id는 고유해야하고, 시간 순서와 일치해야한다. 스노플레이크같은 생성기를 이용하거나, 굳이 전역적일 필요가 없으므로 지역 순서 번호 생성기를 이용해본다. 

# 상세 설계
## 서비스 탐색 
클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이다. 클라이언트의 위치, 서버의 용량 등을 고려한다. 이에는 아파치 주키퍼와 같은 것이 사용될 수 있다. 사용 가능한 모든 채팅 서버를 등록시켜두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라준다.

## 메시지 흐름
### 1:1 채팅 메세지
메시지 전송 -> 채팅 서버-> 메시지 동기화 큐 겸 키 값 저장소에 저장 -> 상대가 접속 중이면 해당 클라이언트 서버로, 아니면 푸시알림 서버로 전달

### 여러 단말 사이의 메시지 동기화
두 대 단말을 이용하고 있다 가정했을 때, 핸드폰으로 앱에 로그인하면 채팅 서버와 해당 단말 사이에 웹소켓 연결이 만들어져있고, 다른 단말로 로그인한 결과로 별도 웹소켓이 채팅 서버에 연결되어잇다. 각 단말은 cur_max_msg_id 변수를 유지하며, 해당 단말에서 관측된 가장 최신 메시지의 id를 추적한다. 
- 수신자 Id가 현재 로그인한 사용자 Id와 같고
- 키-값 저장소에 보관된 메시지로서, 그 id가 cur_max_msg_id보다 크면 새 메시지로 간주한다. 

### 소규모 그룹 채팅에서의 메시지 흐름
1:1보다 더 복잡하다. 

A가 보낸 msg가 B, C의 메시지 동기화 큐에 각각 복사된다. 
- 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 돼서 메시지 동기화 플로우가 단순하다. 
- 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 크지않다. 

따라서 이는 적은 사용자를 지원하기에 좋은 방법이다. 

### 접속상태 표시
- 로그인: 웹소켓이 연결되면 접속 상태 서버가 상태와 last_acive_at timestamp값을 키-값 저장소에 보관한다. 
- 접속 장애: 박동 검사를 통해, 마지막 이벤트를 받은지 x초 이내에 박동 이벤트 메시지를 받으면 계속 온라인 처리한다.
- 상태 정보의 전송: 발행-구독 모델 (펍섭)로, 각 친구관계마다 채널을 하나씩 두게된다. 각각의 친구관계마다 채널을 하나씩 두게된다. 그러나 이는 그룹 크기가 작을 때 효과적이다. 10만 사용자면 10만개의 이벤트 메시지가 발생할 것이다..! 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 수동으로 하도록 유도한다.

