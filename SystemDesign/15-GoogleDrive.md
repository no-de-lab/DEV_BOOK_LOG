## 필요한 API 
1. 파일 업로드
2. 파일 다운로드
3. 파일 갱신 히스토리

이 모두는 사용자 인증과 SSL이 필요하다.

## 개략적 설계
1. 사용자 단말
2. 블록 저장소 서버: 파일 블록을 클라우드 저장소에 업로드하는 서버다. 각 블록에는 고유한 해시값이 할당된다. 이 해시값은 메타데이터 데이터베이스에 저장된다. 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야한다.
3. 클라우드 저장소: 파일은 블록 단위로 나눠져 클라우드 저장소에 보관된다. 
4. 로드밸런서: 요청을 모든 api 서버에 고르게 분산한다.
5. API 서버: 파일 업로드 외에 거의 모든 것을 담당하는 서버다. 사용자 인증이나 프로파일 관리, 파일 메타데이터 갱신 등에 사용된다.
6. 메타데이터 데이터베이스: 사용자나 파일 , 블록, 버전 등의 메타데이터 정보를 관리한다. 실제 파일은 클라우드에 보관하고 이 데이터베이스는 메타 정보만 둔다.
7. 메타데이터 캐시: 성능을 높이기 위해 자주 쓰이는 메타데이터는 캐시한다.
8. 알림 서비스: 특정 이벤트가 발생했음을 클라이언트에 알리는 데 쓰이는 pub/sub 기반 시스템이다. 
9. offline 사용자 백업 큐: 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 둔다. 후에 동기화되도록한다.

## 설계 상세
### 블록 저장소 서버
정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹게 된다. 이를 최적화하는 방법으로는 두 가지 정도를 생각해볼 수 있다. 
1. 델타 동기화: 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화한다.
2. 압축: 블록 단위로 압축하면 데이터 크기를 많이 줄일 수 있다.

블록 저장소 서버는 클라이언트가 보낸 파일을 블록 단위로 나눠야하고 각 블록에 압축 알고리즘을 적용하고 암호화도 해야한다. 또한, 전체 파일을 저장소 시스템으로 보내는 것이 아니라 수정된 블록만 전송해야한다.

### 높은 일관성 요구사항
캐시에 보관된 사본과 데이터 베이스에 있는 원본이 일치하고, 변경이 일어나면 캐시를 무효화하는 작업이 필요하다.
관계형 데이터베이스는 ACID를 제공하나, Nosql의 경우는 동기화 로직 내에 프로그래밍을 해야한다.

### 알림 서비스
파일의 일관성을 유지하기 위해 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간, 다른 클라이언트에 그 사실을 알려서 충돌 가능성을 줄여야한다. 

채팅 서비스와는 달리 양방향 통신이 필요하지는 않아서 롱 폴링을 사용하면 된다. 각 클라이언트는 알림서버와 롱 폴링용 연결을 유지하다가, 특정 파일이 변하면 해당 연결을 끊는다. 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드해야한다. 해당 다운로드 작업이 끝났거나, 연결 타임 아웃 시간에 도달한 경우에는 즉시 새 요청을 보내 롱 폴링 연결을 복원하고 유지해야한다.

### 저장소 공간 절약
버전을 자주 백업하면 저장용량이 너무 빨리 소진되므로, 
- 중복 제거
- 지능적 백업: 한도를 설정하거나, 중요한 버전만 보관한다.
- 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다. 

