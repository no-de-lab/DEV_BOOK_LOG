개략적으로 자동완성 시스템은 두 부분으로 나뉜다.

하나는 데이터 수집 서비스다. 사용자가 입력한 질의를 실시간으로 수집한다. 데이터가 많을 경우엔 바람직하지 않긴하다.

다른 하나는 질의 서비스다. 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는다. 

## 상세 설계
관계형 데이터베이스로 top 5 질의를 하는 것은 효율적이지 않다. 
트라이 자료구조를 이용해서, 보다 효율적인 검색이 가능하게끔 한다.

### 트라이
트리 구조인 트라이는 접두어 노드를 구성하고 그의 자식들은 접두어에 추가적으로 알파벳이 붙을 때마다 생기는 방식으로 뻗어나간다. 

따라서 접두어를 표현하는 노드를 찾고 해당 노드부터 시작하는 하위 트리를 탐색하여 유효 노드를 찾는다. 그리고 그 유효 노드들은 정렬하여 가장 인기있는 검색어 k개를 찾는다. 

시간 복잡도는 위의 각 단계에 소요된 시간의 합이다. 

이 알고리즘은 최악의 경우 k개의 결과를 얻기위해 전체 트라이를 다 검색해야할 수도 있으므로, 접두어의 최대 길이를 제한하고, 각 노드에 인기 검색어를 캐시하는 방식으로 해결한다. 

1. 접두어 최대 길이 제한: 최대 길이를 제한할 수 있다면, O(작은 상수값)으로 바뀔 수 있다.
2. 노드에 인기 검색어 캐시: 이 경우 시간 복잡도를 엄청나게 낮출 수가 있지만, 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다. 

### 데이터 수집 서비스
사용자가 검색창에 타이핑 할 때마다 실시간으로 수정하는 것은 
1. 트라이 갱신이 실시간으로 이뤄지므로 질의 서비스가 느려지게 된다는 점
2. 인기 검색어가 그렇게 자주 바뀌지 않을 것이므로 트라이가 자주 갱신될 필요가 없다는 점에서 실용적이지 않은 방법이다. 

데이터 분석 서비스 로그 -> 로그 취합 서버-> 취합된 데이터를 작업하는 서버-> 트라이 데이터베이스 매주 갱신 -> 트라이 캐시를 만드는 방식으로 트라이를 갱신하면 된다. 

이 트라이 데이터 베이스는 몽고db같은 문서 저장소나 혹은 -값 저장소를 사용할 수 있다. 

### 질의 서비스
매우 빨라야한다. ajax요청이나 브라우저 캐싱, 데이터 샘플링 등으로 최적화한다. 

### 트라이 연산 
트라이 생성은 작업 서버가 담당하고, 트라이 갱신은 매주 한번 갱신하거나 트라이가 작은 경우 각 노드를 개별적으로 갱신한다. 이 때는 한 노드가 갱신될 때 상위 노드도 갱신되어야한다는 점을 잊으면 안된다. 검색어 삭제의 경우 트라이 캐시와 서버 사이에 필터를 둔다. 

### 저장소 규모 확장
데이터베이스 샤딩을 한다. 근데 알파벳 수로 나누게 되면 각 알파벳에 따른 단어 양이 균일하지 않으므로, 과거 질의 데이터의 패턴을 분석하여 샤딩하는 것이 필요하다. 

