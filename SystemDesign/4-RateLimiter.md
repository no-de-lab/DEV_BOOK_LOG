처리율 제한 장치란, 클라이언트나 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치다. ex. HTTP의 경우 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다. 
이는 DoS 공격에 의한 자원 고갈을 방지할 수 있다. 비용 절감이나 서버 과부하 막는 효과도 있다. 

이는 주로 서버 측에 제한 장치를 두거나 미들웨어를 두고, 아니면 API 게이트웨이를 두어 클라이언트 요청을 사전에 검사한다. 
이에 대한 결정은 여러 상황에 따라 달라진다.
- 기술스택
- 처리율 제한 알고리즘
- 설계가 마이크로 서비스라면 게이트웨이에 두는 것이 좋다. 
- 상용 API 게이트웨이를 쓸 수도 있다. 

## 처리율 제한 알고리즘
1. 토큰 버킷 알고리즘

지정된 용량을 가지는 토큰 버킷이 꽉차면 더이상 토큰이 추가되지는 않는다. 

각 요청은 처리될 때마다 하나의 토큰을 사용한다. 충분한 토큰이 없으면 이 요청은 버려진다.
이는 구현이 간단하고 메모리 사용도 효율적이지만, 버킷 크기와 토큰 공급률이라는 인자를 적절히 조절하기가 까다롭다.

2. 누출 버킷 알고리즘

토큰 버킷알고리즘과 비슷하지만, 고정 속도로 요청을 처리한다는 점이 다르다. 

큐 형태로 버킷이 있고, 요청이 그 버킷에 쌓인다. 버킷이 다 차면 요청은 버려진다. 

메모리 사용량 측면에서는 효율적이고 안정적으로 출력된다는 점이 잇지만 단시간에 많은 트래픽이 몰리면 큐에는 오래된 요청이 쌓인다. 더불어 이 또한 버킷 크기와 토큰 공급률 두개의 인자가 있어 조율이 까다롭다.

3. 고정 윈도 카운터 알고리즘
타임라인을 고정된 간격의 window로 나눈뒤에 각 윈도마다 counter를 붙여, 요청이 접수될 때마다 +1씩 카운터를 올린다. 이 값이 임계치에 도달하면 새 윈도가 열릴 때까지 요청은 버려진다. 

이 알고리즘은 윈도의 경계부근에 순간적으로 많은 트래픽이 집중되면 윈도 할달량보다 많은 요청이 처리될 수 있다는 점이다.

4. 이동 윈도 로깅 알고리즘

위의 알고리즘을 보완한 이동 윈도 로깅 알고리즘이 있다. 

이는 요청의 타임스탬프를 추적하여, 새 요청이 오면 윈도의 시작 시점보다 오래된 타임스탬프는 제거한다. 로그의 크기가 허용치보다 같거나 작으면 요청을 전달하지만 아니면 처리를 거부한다. 

이는 정교하지만 다량의 메모리를 사용한다. 거부된 요청의 타임스탬프도 보관하기 때문이다.

5. 이동 윈도 카운터 알고리즘: 고정 윈도 카운터 + 이동윈도 로깅 결합작이다. 

처리율 제한 장치의 한도가 분당 7개면, 이전 1분간 5개, 현재 1분간 3개의 요청이 있고 현재 1분의 30% 시점에 도착했다고 할 때, 비율로 현재 윈도의 요청을 계산한다. 3+5*70% = 6.5개로 계산하는 것이다. 내림하여 6개로 한다. 

이는 요청이 균등하게 분포되어있다고 가정한 상태에서 추정치를 계산하므로 다소 느슨하다. 그래도 큰 문제가 있지는 않다. 

## 처리율 제한 규칙은 어디에 저장되고 어떻게 만들어지는가.
- 처리율 규칙 자체는 디스크에 보관하고, 작업 프로세스가 수시로 규칙을 캐시에 저장한다. 
- 클라이언트가 요청을 서버에 보내면, 요청은 먼저 처리율 제한 미들웨어에 도달해서 제한 규칙을 기준으로 결정을 내린다. 
- 해당 요청이 처리율 제한에 걸렸다면 429를 내뿜는다.

## 분산 환경에서의 처리율 제한 규칙
- 경쟁조건: 주로 락을 쓰는데 락은 시스템의 성능을 상당히 떨어트리므로, 루아 스크립트나 정렬집합(레디스)을 사용한다.
- 동기화: 고정 세션을 활용해서 같은 클라이언트로부터의 요청을 항상 같은 처리율 제한 장치로도 보낼 수 있으나, 이는 확장이 불가하고 유연하지도 않다. 추천 방법은 레디스와 같은 중앙 집중형 데이터 저장소를 사용하는 것이다.

## 이외에
- 성능 최적화: 가까운 에지 서버로 전달하여 지연시간을 줄이고, 최종 일관성 모델을 통해 제한 장치 간에 데이터를 동기화한다.
- 모니터링: 효과적으로 동작하는지 보아야한다. 