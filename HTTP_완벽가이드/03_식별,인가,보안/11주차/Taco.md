Http는 콘텐츠를 잘 나르기 위해 잘 라벨링 된 엔티티를 사용

## 메세지는 컨테이너, 엔티티는 화물
Http 내부 실질적 메세지가 엔티티
엔터티 본문은 가공되지 않은 데이터만을 담고 있기 때문에 엔터티 헤더는 그 데이터의 이미에 대해 설명할 필요가 있다.
> 엔티티 헤더와 엔티티 본문 사이는 CRLF로 구분된다.

## Content-length
- 메세지가 제대로 전달되고 있는지, 잘림은 없는지, 지속커넥션을 뒷받침해주기위한 역할
- 잘못된 Content Length가 전달될 때도 있기 때문에 이를 교정하려는 노력도 존재
- 인코딩돼있다면, 인코딩된 본문의 길이를 전달

## 체크섬으로 엔티티의 변경을 잡아내다
- Content-MD5 헤더는 서버가 보낸다. 전송 인코딩 이전에! 
- 그 사이 프락시나 캐시는 그를 건드리지 않는다
- 클라이언트에게 와서, 무결성 검사가 진행되는데, 전송 디코딩 후 엔터티 본문에 대해 MD5를 계산한다.

## 미디어타입과 차셋 
- Content-type 엔티티 헤더는, 인코딩 전의 엔티티 본문 유형을 명시하기 때문에 중요! 
- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위해 차셋 매개변수를 주기도

## 컨텐츠 인코딩
- 서버가 인코딩을 해서 클라이언트에 응답
- gzip이 자주 쓰이는듯
- 무손실 압축 알고리즘
- 근데 막 인코딩하면 안되고, 클라이언트 입장에서 Accept-Encoding 헤더를 통해 디코딩 할 수 있는 목록을 보낸다.
- 여기에도 매개변수는 있다. Q를 주어서 선호도를 나타낼 수 있다. 

## 전송인코딩과 청크 인코딩
- 컨텐츠의 포맷과는 관계없이, 메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송인코딩을 사용한다. 
- 안전히 전송하기위해. 크기를 알 수 없지만 Content-Length 헤더가 있어야 해서 임의로 포함시켜 데이터를 보내려고 한다.
- 보안 전송 인코딩도 있는데, SSL이 있으므로 흔하지는 않다
- Transfer-Encoding(서버)와 TE(클라이언트) 헤더로 전송 인코딩 어떻게 썼는지 주고받는다.
- 청크 인코딩은 전송 인코딩의 한 형태로, 서버가 본문을 여러 청크로 쪼개 보내는 것 
- 컨텐츠와 전송 인코딩을 같이 할수도 있다.

## 검사기와 신선도
- 내가 가지고 있는 버전이 어떤 버전인줄 알고? 
- 캐시와 관련한 신선도 체크

## 범위요청
- 버전이 같은 경우에 한해, 중단된 응답 시점에서 다시 요청 가능 (Range 태그)

## 델타 인코딩
- 데이터가 변경된 부분만을 업데이트하는
- A-IM 헤더를 통해, 델타로 가능하다는 것을 알린다
- 기반이 된 ETag 를 Delta-base로 응답한다.
