# 14장 보안 HTTP

### 필요한 보안기술
- 인증 : 서버/클라 서로가 진짜인지 알 수 있어야함 
- 무결성 : 데이터 위조로부터 안전
- 암호화 : 외부로부터 도청 금지
- 효율 : 효율적인 알고리즘 
- 편재성 : 프로토콜은 거의 모든 클라/서버 지원
- 확장성 : 사용자, 장소가 무엇이든 즉각적인 보안 통신

### HTTPS 
- HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 갈력한 집합을 결합한 것  
- http 요청/응답 데이터가 네트워크로 보내지기 전에 암호화  
- 보안 HTTP사용하는데 SSL 또는 TLS에서 인코딩/디코딩 작업이 일어나기에, 클라/서버에서 프로토콜 처리하는 로직을 크게 변경할 필요 없음.


### HTTP -> HTTPS 
- 메세지를 TCP로 보내기 전 SSL(보안계층)으로 보낸다.
- URL 스킴이 HTTPS 경우, 443 기본 포트(HTTP은 80)
- SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와 완전히 다르다. 만약 HTTP 80번 포트로 간다면, 잘못된 HTTP로 해석하여 커넥션 닫힘.

### HTTPS 트랜잭션
- 서버의 443포트로 TCP 커넥션 수립
- SSL 보안 매개변수 핸드셰이크
- HTTP 요청 -> SSL / 암호화된 요청 -> TCP
- HTTP 응답 -> SSL / 암호화된 응답 -> TCP
- SSL 닫힘
- TCP 커넥션 닫힘


### SSL 핸드쉐이크
암호화된 HTTP 메세지 보내기 전, 클라/서버는 SSL 핸드셰이크 필요
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

### 서버 인증서
SSL은 서버 인증서를 클라이언트로 전송하고 다시 클라이언트 인증서를 서버로 전송하는 상호 인증을 지원한다.   
클라이언트 인증서는 오늘날 웹 브라우징에선 흔히 쓰이지 않는다. 하지만 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.  
서버 인증서는 서버를 얼마나 신뢰할 수 있는지 평가하는 것에 도움을 준다.  

### 프락시를 통한 보안 트래픽 터널링 
클라는 원서버대신 프락시서버를 이용함, 클라가 서버에 보낼 데이터를 서버의 공개키로 암호화했다면, 
프락시는 HTTP헤더를 읽을 수 없음 -> 프락시가 어디로 응답을 어디로 해야하는지 모름
때문에 `HTTPS SSL 터널링 프로토콜` 기법을 사용하여 문제를 해결한다. 

- 클라이언트는 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말함
- HTTP CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말함
- 완료되면 클라이언트와 서버 사이에서 데이터가 오갈 수 있게 터널을 만듦



### SSL 암호화
- 대칭Key
  - 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법
- 공개Key
  - 대칭키는 암호를 주고받는 사람들 사이에서 전달 어려움, 유출되면 망 때문에 공개키 방식이 나옴
  - A키를 암호화 -> B키로 복호화, B키로 암호화 -> A키로 복호화
  - 쌍을 이루는 키를 가진다. 
  - 비공개키(private key, 개인키, 비밀키): 복호화 가능, 공개키(public key): 암호화



### 
[기본 포트 번호](https://docs.oracle.com/cd/E19636-01/819-5409/a-portnum.html)
[SSL(Secure Socket Layer) 이란](https://12bme.tistory.com/80)