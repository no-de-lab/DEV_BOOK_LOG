### 3장 HTTP 메세지

시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열 
캐리지 리턴 (ASCII 13) 개행 문자 (ASCII 10) 로 구성된 두 글자의 줄바꿈 문자열(CRLF)

#### 시작줄 
요청&응답 메세지의 필드는 공백으로 구분된다.
- 요청메세지 ```메서드``` ```요청 URL``` ```버전```
  - 메서드  
  서버가 무엇을 해야 하는지 포함, 메서드에 따라 본문의 유무 다르다.  
  HTTP는 쉽게 확장할 수 있도록 설계되어 메서드를 추가할 수 있다.
    - GET(x)
    - HEAD: 서버에서 어떤 문서에 대해 헤더만 가져옴 (x)
    - POST (o)
    - PUT (o)
    - TRACE: 메세지가 프락시를 거쳐 서버에 도달하는 과정을 추적 (x)
    - OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인 (x)
    - DELETE (x)
    - PATCH : 리소스를 일부만 변경
    - CONNECT: 서버에 대한 터널을 설정
    - 확장메서드
  - 버전
    - HTTP/<메이저>.<마이너>
    - 앱이 지원하는 가장 높은 HTTP 버전을 가르킨다.

- 응답메세지 ```버전``` ```상태코드``` ```사유구절```
  - 상태코드  
  서버에서 무슨 일이 일어났는지 알려주는 코드  
  프로토콜의 확장됨으로 상태코드도 추가된다. 모르는 상태코드라고 하더라도,어느 범위안에 든다면, 그 구성원으로 간주하면 됨
    - 1XX 정보
      - 서버가 요청을 받았고 클라이언트는 계속 진행하라
      - _HTTP/1.0에서는 지원안함_
    - 2XX 성공
    - 3XX 리다이렉션
      - 영속적인 리다이렉션: 웹사이트 재편성
        - 요청한 URI의 리소스가 영구적으로 변경되었음을 의미
        - ```301```
        - ```308```
      - 일시적인 리다이렉션: ex) PG이용
        - 요청한 URI의 리소스가 일시적으로 변경되었음을 의미
        - ```302``` 
        - ```303``` (본문을 잃게 됨, 뒤로가기 안됨)  
        동작을 다시 촉발시키는 페이지 리프레시를 막기 위해 PUT 혹은  POST 뒤에 사용
        - ```307```
    - 4XX 클라이언트 에러
    - 5XX 서버에러(내 잘못 아니라고!)
  - 사유구절 : 사람이 이해하기 쉬운 버전 딱히 규칙이 없다.

#### 헤더 

- 일반헤더 
- 요청헤더: 요청에 대한 부가 정보 제공
  - UA-** : 클라이언트 기기정보 (-> User-Agent 로 다 커버될 듯?)
- 응답헤더: 응답에 대한 부가 정보 제공
- Entity 헤더: 본문크기와 콘턴체 혹은 리소스 그 자체를 서술
  - ex) content-length, content-type
- 확장헤더: 명세에 정의되지 않은 새로운 헤더

 
#### 엔터티 본문
HTTP 메세지의 화물 - 여러종류의 디지털 데이터를 실어 나를 수 있다.

> HTTP 0.9 메세지는 버전, 상태코드, 사유 구절도 없었음  

#### 메서드
모든 서버가 모든 메서드를 구현하지는 않는다. 
>HTTP 1.1과 호환되고자 한다면, ```GET``` ```HEAD``` 메서드만을 구현하는 것으로도 충분하다. 

- GET
  - 서버에 리소스 요청하는 메서드
- HEAD 
  - GET 처럼 행동하지만, 응답으로 헤더만 돌려준다.
  - 캐시 된 데이터가 최신의 것인지 확인하기 위함이라면 HEAD 메서드를 쓰는 것이 효율적
- PUT
  - 경험상 서버에 데이터 업데이트 할때 주로 사용
  - 요청 URI가 최초로 사용될 경우 생성 그 후로는 업데이트
- POST
  - 입력 데이터를 전송하기 위해 설계 (html form)
  - 새로운 데이터를 생성할때 사용
- TRACE
  - 클라이언트가 자신의 요청이 서버에 어떻게 도달했을때 어떻게 보이게 되는지 알려줌
  - 서버가 요청 메세지를 본문에 넣어 TRACE 응답으로 돌려줌
  - 주로 진단을 위해 사용된다. (디버깅용)
  - 보안에 취약하여(세션, 토큰값이 유출됨) 서버에서 요청메소드를 제안할 수 있음
- OPTIONS
  - 서버가 어떤 종류의 메소드를 지원하는지 물어봄
- DELETE
  - 클라이언트가 서버에 지정URL의 리소스 삭제 요청할 때 사용
  - 서버는 클라이언트 요청을 수행/무시 할 수 있음
  - 때문에 클라이언트는 삭제가 수행되는 것을 보장 못함
- PATCH
  - 리소스 부분 수정에 사용됨 (PUT 과 다른점)
- CONNECT
  - 요청한 리소스에 대해 양방향 연결을 시작하는 메소드
  - 터널을 열기 위해서 사용될 수 있음
  - ex ) SSL (HTTPS)를 사용하는 웹사이트에 접속하는데 사용될 수 있음
- 확장 메소드
  - HTTP/1.1 명세에 정의되지 않은 메서드
  - 프락시는 (end-to-end)종단 간 행위를 망가뜨리지 않을 수있드면, 알려지지 않은 메서드가 담긴 메세지를 다운스트림 서버로 전달하려고 시도


#### 안전한 메서드
HTTP 요청에도 서버에 어떤 작용도 없음을 의미 
안전한 메서드는 _멱등성_ 또한 갖지만, _모든 멱등성을 지닌 메서드가 안전한 것은 아니다._
- ```GET``` 
- ```HEAD``` 
- ```OPTIONS```



 
--- 
생각되는 점  
- 모던 브라우저(크롬) 네트워크 탭 베뤼 감사합니다.
---
의문  
- 견고한 애플리케이션이라면 그냥 개행 문자도 받아 들일 수 있어야한다?
- 왜 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야 하지?

---
참고  
- [이번 챕터 잘 정리한 블로그](https://feel5ny.github.io/2019/08/16/HTTP_003_02/)
- [상태코드 정리](https://www.whatap.io/ko/blog/40/)
- [HTTP 버전](https://krksap.tistory.com/1152)
- [안전한 메서드와 HEAD 메서드의 사용](https://kscodebase.tistory.com/330)
- [HEAD 왜 쓸까?](https://straw961030.tistory.com/246)
- [http HEAD vs GET performance](https://stackoverflow.com/questions/16539269/http-head-vs-get-performance)
- [POST VS PUT](https://velog.io/@53_eddy_jo/RESTful%ED%95%9C-%EC%84%B8%EA%B3%84%EC%97%90%EC%84%9C%EC%9D%98-POST%EC%99%80-PUT%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EA%B1%B0%EA%B8%B0%EC%97%90-FETCH%EA%B9%8C%EC%A7%80)
- [TRACE 취약점](https://mokpo.tistory.com/202)
- [CONNECT 취약사례](https://pitsec.tistory.com/19)
- [HTTP 상태 코드 301에서 303](https://cherrypick.co.kr/avoid-location-header-cache-in-brower-using-303-http-code/)

읽어볼 것
- [HTTP/3](https://evan-moon.github.io/2019/10/08/what-is-http3/)
- [HTTP/1 부터 HTTP/3 까지 알아보기](https://velog.io/@ziyoonee/HTTP1-%EB%B6%80%ED%84%B0-HTTP3-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
- [HTTP3 적용](https://doda.dev/posts/http3-and-nginx) 