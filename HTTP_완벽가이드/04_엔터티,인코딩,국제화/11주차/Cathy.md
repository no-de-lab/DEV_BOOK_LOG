# 15장 엔터티와 인코딩

HTTP 수십업개의 미디어 객체를 실어 나르는데 다음을 보장한다.   
- 객체의 올바른 식별
- 압출풀이
- 항상 최신
- Accept 관련 헤더들에 기반하여, 사용자 요구 만족
- 네트워크 사이를 효율적 이동
- 조작되지 않음 

이러한 보장을 위해, _잘 라벨링된 엔터티_ 를 사용한다.  

## 메세지는 컨테이너, 엔터티는 화물 

- 엔터티 헤더 필드
  - Content-Type: 객체의 종류

  - Content-Length: 메세지 길이나 크기
    - 크기를 바이트
    - gzip 압축된 경우 압축된 후 크기
    - _서버 충돌로 인해 메세지에 손상이 없는지 감지하고자 할 때 필요_
    - 없으면, 클라에서 커넥션이 정상적으로 닫혔는지 구분을 못함
    - 없어서 검출하지 못하면 _잘못된 메세지를 캐싱함_

  - Content-Language: 객체와 잘 대응되는 자연어
  - Content-Encoding : 객체 데이터에 행해진 변형 ( ex. 압축 )
  - Content-Location : 요청 시점을 기준으로 객체의 또 다른 위치
  - Content-Range: 부분 엔터티라면, 전체에서 어디 부분에 해당하는지 정의
  - Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬
  - Last-Modified
  - Expires : 데이터에 대한 유통기한 ( 비유하자면 그렇다. )
  - Allow : 어떤 요청 메서드가 허용되는지
- 엔터티 헤더는 아니지만 중요한 것
  - Etag : 인스턴스 고유 검사기
  - Cache-Control : 문서가 어떻게 캐시 될 수 있는지에 대한 지시자

엔터티 본문 길이 판별 규칙
- 본문이 허용되지 않는 특정 HTTP는 content-length가 무시됨
- Transfer-Encoding 헤더를 포함한다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 0 byte 청크라고 불리는 특별 패턴으로 끝남 (반드시 content-length 헤더 무시)
- Transfer-Encoding가 헤더에 없다면, content-length 값은 본문의 길이
- 멀티타입은 자신 스스로 크기를 결정 할 수 있는 유일한 텐터티 본문


Content-Length 생각보다... 중요했구나


## 콘텐츠 인코딩

인코딩 과정 
- 웹 서버가 원본 Content-Type & Content-Length 헤더를 수반한 원본 메시지 생성
- 콘텐츠 인코딩 서버가 인코딩 된 메시지를 생성. 
- Content-Type은 같지만, Content-Length는 달라짐. 
- Content-Encoding 헤더를 인코딩된 메시지에 추가하고 디코딩을 할 것을 알림
- 수신 측은 디코딩하여 원본을 얻음

인코딩 유형
- HTTP 는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용
- 인코딩은 콘텐츠 알고리즘에 대한 고유한 토큰을 할당하는 IANA를 통해 표준화

  - gzip : 32비트 CRC와 함께 Lempel-Ziv coding (LZ77)를 사용하는 압축 포맷.
  - compress : Lempel-Ziv-Welch (LZW) 알고리즘을 사용하는 압축 포맷
  - deflate : deflate 압축 알고리즘과 함께 zlib 구조를 사용하는 압축 포맷.
  - identify : 어떤 인코딩도 수행되지 않음. Content-Encoding이 없을 경우 identify로 처리한다.
  - br: Brotli 알고리즘을 사용하는 압축 포맷.

gzip, compress, deflate 무결성 압축 알고리즘이며, 이 중에서 gzip이 가장 효율적이며 널리 쓰인다.

인코딩 Q값 ? <0.0 ~ 1.0>  
weight라고 부르는 _상대적인 퀄리티 값을 사용하여 표현한 선호도_ 에 따라 배치된 값
> 궁금점.....   
> 선호도 어떻게 측정...?

## 전송인코딩 청크인코딩
전송 인코딩 또한 엔터티 본문에 적용되는 변환이지만 콘텐츠의 포맷과는 독립적
메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있음

전송인코딩
- 안전한 전송을 위해 존재
  - 알 수 없는 크기: 어떤 서버들은 콘텐츠의 전체 크기를 미리 알기 전부터 데이터의 전송을 시작
  


청크인코딩
- 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보냄
- 청크 인코딩은 본문이 아닌 메시지의 속성
- 멀티파트 인코딩은 본문의 속성이고 청크 인코딩과는 완전히 분리

청크와 지속 커넥션
- 클라이언트/서버간의 커넥션이 지속적이지 않다면, 클라이언트는 읽을 본문의 크기를 알 필요가 없음
- 지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야함
- 하지만, 콘텐츠가 서버에서 동적으로 생성되는 경우에는 보내기 전에 본문의 길이를 알아내는 것이 불가능
- 때문에 청크 인코딩은 서버가 본문을 여러 청크로 쪼개서 보낼 수 있도록 하여 해결
- 서버는 크기가 0인 청크로 분문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지


## 검사기와 신선도
조건부 요청은 클라가 서버에게 자신이 갖고있는 버전을 말해주고, 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것


신선도 -> Expires & Cache-Control 헤더를 통해 정보를 제공
조건부 -> 항상 다시 갖고 온다면 불필요한 리소스 낭비, 때문에 조건부 사용 (보통 If-* 들어가면 조건부)
  - If-Modified-Since : Last-Modified 변하면
  - If-Unmodified-Since : Last-Modified 변한게 없으면
  - If-Match : ETag 같으면
  - If-None-Match : ETag 다르면









----




