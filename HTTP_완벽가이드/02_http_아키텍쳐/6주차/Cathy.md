## 캐시

### 캐시사용되는 이유
- 불필요 데이터 전송
  - 처음 원서버에서 데이터를 받고, 캐싱하여 중복되는 서버요청에 원서버는 같은 데이터를 다시 보내 필요없음.
  - 트래픽 낭비를 줄여준다.
- 네트워크 병목현상 방지
  - 원격 서버보다 로컬 네트워크 클라에 더넓은 대역폭 제공
  - 네트워크 속도에 갭으로 클라이언트가 느린 속도에 맞춰 서버에 접근할 수 밖에 없음 
  - 이런 문제점을 고속 LAN에 연결하여 40%를 캐시로 돌린다면, 60%만 접속회선을 통과하므로 _트래픽 강도는 1.0에서 0.6으로 감소_
  - CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며, 이를 통해 많은 트래픽을 지역화
- 갑작스런 요청쇄도
  - 티켓팅 같이 갑자기 요청이 동시에 몰릴때 서버 트래픽 감량, 에러를 방지하기 위해 사용
- 거리로 인한 지연 


### 캐시의 적중과 부적중 
- cache git(적중) : 요청한 데이터가 캐시 사본가 맞는 경우
- cache miss(부적중) : 사본가 맞지 않아서 요청이 원 서버로 전달 되는 것
- 컨텐츠는 변경되기 때문에 캐시가 최신인지 종종 검사를 해야함 이것을 http 재검사라 보른다. 
- 재검사를 요청을 위해 GET 요청 헤더에 ```If-Modified-Since``` 를 추가
  - 재검사 적중 : 캐시 사본 변경 없음 HTTP 304 응답
  - 재검사 부적중 : 사본 변경으로 서버는 컨텐츠 & HTTP 200응답
  - 객체 삭제 : 캐시 사본이 삭제됨 404 not found
- 캐시의 적중률이 40%라면 꽤 적중률이 높다고 본다. 높으면 높을수록 트래픽 강도가 낮아지고 성능개선됨
- 바이트 단위 적중률 : 캐시를 통해 제공된 모든 바이트의 비율 
  - 이 측정값은 트래픽이 절감된 정도를 포착
- 캐시가 얼마나 적중되는지 확인이 잘 안된다. 그래서 상용 프록시 캐시는 via 헤더에 추가 정보를 붙임.
- 클라이언트가 캐시된 응답 감지방법은 Age 헤더를 이용 (cache-control : max-age=0 || no-catch)


### 캐시 토폴로지
- 개인 전용
  - 웹브라우저 개인 전용 캐시 내장
  - 자주 들어가는 사이트, 로그인 정보 저장 
  - 개발하고 로컬에서 테스트 하는데 캐시때문에 제대로 업데이트 되지 않은 적이 몇 번 있었지..
- 공용 (=프록시서버)
  - 여러 사용자가 접근하는 컨텐츠를 한번 가져와 다른 사용자에게도 공유된 사본을 제공해서 서버에 불필요 트래픽 감소 
- 캐시망 콘턴츠 라우팅, 피어링 

### 캐시 처리단계 
- 요청받기
- 파싱
- 검색
  - 탐색? 검색 알고리즘 사용?  
- 신선도 검사
- 응답 생성
- 전송
- 로깅

### 사본 신선유지 
- ```Cache-control, Expires``` 특별헤더 이용하여 유효기간 
  - ```Expires``` JWT 토큰관리 할때 종종 사용한듯..  
- 서버재검사 
  - next.js 의 revalidate ? 같은 것 ? 


### 참고자료
[웹 캐시(Web Cache; 프록시 서버)를 통한 응답 속도 향상 원리 이해하기](https://studyandwrite.tistory.com/431)


