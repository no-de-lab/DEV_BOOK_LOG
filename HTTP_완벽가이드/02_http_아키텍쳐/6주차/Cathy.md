## 캐시

### 캐시사용되는 이유
- 불필요 데이터 전송
  - 처음 원서버에서 데이터를 받고, 캐싱하여 중복되는 서버요청에 원서버는 같은 데이터를 다시 보내 필요없음.
  - 트래픽 낭비를 줄여준다.
- 네트워크 병목현상 방지
  - 원격 서버보다 로컬 네트워크 클라에 더넓은 대역폭 제공
  - 네트워크 속도에 갭으로 클라이언트가 느린 속도에 맞춰 서버에 접근할 수 밖에 없음 
  - 이런 문제점을 고속 LAN에 연결하여 40%를 캐시로 돌린다면, 60%만 접속회선을 통과하므로 _트래픽 강도는 1.0에서 0.6으로 감소_
  - CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며, 이를 통해 많은 트래픽을 지역화
- 갑작스런 요청쇄도
  - 티켓팅 같이 갑자기 요청이 동시에 몰릴때 서버 트래픽 감량, 에러를 방지하기 위해 사용
- 거리로 인한 지연 


### 캐시의 적중과 부적중 
- cache git(적중) : 요청한 데이터가 캐시 사본가 맞는 경우
- cache miss(부적중) : 사본가 맞지 않아서 요청이 원 서버로 전달 되는 것
- 컨텐츠는 변경되기 때문에 캐시가 최신인지 종종 검사를 해야함 이것을 http 재검사라 보른다. 
- 재검사를 요청을 위해 GET 요청 헤더에 ```If-Modified-Since``` 를 추가
  - 재검사 적중 : 캐시 사본 변경 없음 HTTP 304 응답
  - 재검사 부적중 : 사본 변경으로 서버는 컨텐츠 & HTTP 200응답
  - 객체 삭제 : 캐시 사본이 삭제됨 404 not found
- 캐시의 적중률이 40%라면 꽤 적중률이 높다고 본다. 높으면 높을수록 트래픽 강도가 낮아지고 성능개선됨
- 바이트 단위 적중률 : 캐시를 통해 제공된 모든 바이트의 비율 
  - 이 측정값은 트래픽이 절감된 정도를 포착
- 캐시가 얼마나 적중되는지 확인이 잘 안된다. 그래서 상용 프록시 캐시는 via 헤더에 추가 정보를 붙임.
- 클라이언트가 캐시된 응답 감지방법은 Age 헤더를 이용 (cache-control : max-age=0 || no-catch)


### 캐시 토폴로지
- 개인 전용
  - 웹브라우저 개인 전용 캐시 내장
  - 자주 들어가는 사이트, 로그인 정보 저장 
  - 개발하고 로컬에서 테스트 하는데 캐시때문에 제대로 업데이트 되지 않은 적이 몇 번 있었지..
- 공용 (=프록시서버)
  - 여러 사용자가 접근하는 컨텐츠를 한번 가져와 다른 사용자에게도 공유된 사본을 제공해서 서버에 불필요 트래픽 감소 
- 캐시망 콘턴츠 라우팅, 피어링 

### 캐시 처리단계 
- 요청받기 & 파싱
  - 요청 메시지를 읽는다. 메시지를 파싱하여 URL과 헤더들을 추출
- 검색
  - 요청에 대응하는 로컬 복사본이 있는지 검사하고, 사본이 없다면 서버에서 데이터를 받아온다.(그리고 복사본을 로컬에 저장한다.) 사본이 있다면 다음 단계를 진행
  - 탐색? 검색 알고리즘 사용?  
- 신선도 검사
  - 캐시된 사본이 신선한지 검사
- 응답 생성
  - 새로운 헤더와 캐시된 본문으로 응답 메세지를 만든다. 캐시는 클라이언트에 맞게 헤더를 수정해야함, 신선도 정보(Cache-Control, Age, Expires 등)를 삽입하며, 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via헤더를 포함
- 전송 : 캐시는 네트워크를 통해 응답을 클라이언트에 돌려줌
- 로깅 : 로그파일에 트랜잭션에 대해 서술한 로그

### 사본 신선유지 
- 문서만료
  - ```Cache-control, Expires``` 특별헤더 이용하여 유효기간을 붙임
  - ```Expires``` JWT 토큰관리 할때 종종 사용한듯..  
- 서버재검사 
  - If-Modified-Since: 날짜 재검사
  - If-None-Match: 엔티티 태그 재검사
  - next.js 의 revalidate ? 같은 것 ? 


### 캐시 제어
HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법

- Cache-Control: no-store
  - 캐시가 response의 사본 만드는 것 금지
- Cache-Control: no-cache
  - 로컬 캐시 저장소에 저장될 수 있음, _서버와 재검사를 하지 않고서는_  캐시에서 클라로 제공될 수 없음
- Cache-Control: must-revalidate
 -  만료 정보를 엄격하게 따르길 원한다면 must-revalidate 응답 헤더
 - 신선도 검사를 시도했을 때 원서버가 사용할 수 없는 상태라면캐시는 반드시 504 Gateway Timeout error를 반환

- Cache-Control: max-age
  - ```max-age``` 신선한 캐시문서가 서버로부터 온 이후 흐른 시간
  - ```max-age=0``` 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시/리프레시 하지 않도록 요청할 수 있음
- Expires 날짜
  - 신선도 수명의 근삿값은 만료일과 생성일의 초 단위 시간차를 계산하여 얻을 수 있음
- 헤더에 아무 정보도 없다면, 캐시는 (휴리스틱) 방법으로 만료 결정




### 참고자료
[웹 캐시(Web Cache; 프록시 서버)를 통한 응답 속도 향상 원리 이해하기](https://studyandwrite.tistory.com/431)
[If-Match,If-Modified-Since,If-None-Match](https://withbundo.blogspot.com/2017/07/http-13-http-iii-if-match-if-modified.html)

