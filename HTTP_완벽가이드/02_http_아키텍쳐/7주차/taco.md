## 8장
### 게이트웨이
필요성: 웹에 더 복잡한 리소스를 올려야한다. 한 개의 애플리케이션으로 모든 리소스를 처리할 수는 없다.
게이트웨이는 리소스를 받기위해 거쳐야하는 경로를 알려주는 역할로서 작동한다. 
즉, 리소스와 애플리케이션을 연결한다.

### 클라이언트-서버를 연결하는 프로토콜
- HTTP/*: 서버 측 게이트웨이
- HTTP/HTTPS: 서버 측 보안 게이트웨이
- HTTPS/HTTP: 클라이언트 보안 가속 게이트웨이
서버 측 보안 게이트웨이는 기업 내부의 모든 웹 요청을 암호화한다.
클라이언트 측 보안 가속 게이트웨이는 보안 트래픽을 받아 복호화하고, 일반 Http 요청을 만들게된다.
- 더 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여준다. 

### 리소스 게이트웨이
우리가 보통 알고있는 API 통신. 
- 최초의 API는 CGI (공용 게이트웨이 인터페이스)
- 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행. 프로그램의 출력 수집. 응답 회신 
- 다만 성능 관련 비용 발생 -> Fast CGI

### 터널
HTTP가 아닌 트래픽을 터널을 통해 통신할 수 있다.
- CONNECT 메서드를 통해 커넥션을 맺는다.
- 다만 터널로 전송되는 데이터는 게이트웨이에서 확인할 수가 없다.
- 성능을 높이기 위해 클라이언트는 터널 데이터를 Connect 요청 보내고 다시 보낼 수도 있다. 게이트웨이가 요청에 이어서 데이터를 적절히 처리할 줄 알아야만한다.

SSL 처리를 터널을 통해 할 수 있다.
기존의 보안 게이트웨이 방식은, 클라-게이트웨이 사이에 보안이 적용되지 않은 일반 HTTP 커넥션이 있고
프락시가 인증을 담당해서 클라이언트가 원격 서버에 SSL 클라이언트 인증을 할 수가 없고
게이트웨이가 SSL을 완벽히 지원해야한다는 단점이 있다. 이 상황에서 터널을 사용을 하면? 프락시에 SSL 구현이 필요없다. 클라이언트와 서버 사이를 연결하기 때문이다.

다만, 터널의 오용이 있을 수 있다. 검증 방법이 없거든! 


### 릴레이
HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시
바이트를 맹목적으로 전달한다.
이 경우 Connection 헤더를 제대로 처리하지 못할 수 있다. 


# 9. 웹로봇

## 사람과의 상호작용 없이, 자동으로 웹 트랜잭션을 수행하는 소프트웨어 프로그램
- 재귀적으로 웹을 순회한다.
- 크롤러가 방문을 시작하는 URL의 초기집합 = 루트 집합
순환에 빠지지 않도록 조심해야한다. 그래서 어디를 방문했는지 알아야한다. 
- 이 순환이라는 것은 웹서버의 부담도 주고, 시간을 계속 허비하게 한다.
- 따라서 이를 극복하기 위해, 방문한 URL을 추적해야한다. 
- 검색 트리나 해시 테이블 사용하거나
- 공간 사용을 최소화하기위해 비트맵을 사용하기도하고,
- 체크포인트를 만들거나 공동으로 일한다.
그래도 어떤 페이지를 이전에 방문했는지 알기 어려워서, URL을 정규화하는 방식으로 해결을 시도한다. 그러나 완전히 이를 해결하긴 어렵다.
- 그래서 휴리스틱한 방법을 이용할 수도 있다.
- 스로틀링처럼 접근 횟수나 중복 총 횟수 제한 , URL 크기 제한 등


## 로봇도 HTTP 명세를 지켜야한다. 
- 가상 호스팅 필요 (여러 사이트를 운영하는 같은 서버에 대한 정보를 정확하게 가져가기 위해)
