## 8장 통합점:게이트웨이,터널,릴레이
다른 프로토콜이나 애플리케이션 간 통산에 HTTP를 어떻게 사용하는지 알아볼 것 

게이트웨이
- 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
app interface
- 서로 다른 형식의 웹 애플리케이션이 통신하는데사용
터널
- HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하데 사용
릴레이
- 단순한 HTTP 프락시로 한번에 한개의 홉에 데이터를 전달하는데 사용

### 게이트웨이
모든 리소스를 한개의 앱으로만 처리할 수 없다는 것이 분명해지고,
이 문제 해결책으로 인터프리터 같이 리소스를 받기 위한 경로안내 역할을 하는 _게이트웨이_를 고안해냄  

게이트웨이는 리소스와 애플리케이션 연결역할을 한다.  
애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고, 게이트웨이는 그에 응답 할 수 있다.

게이트웨이는 _요청을 받고 응답을 보내는 포털같이 동작_   
동적인 콘텐츠를 생성 또는 데이터 베이스에 질의를 보낼 수 있음 

클라이언트 HTTP 통해 리소스 요청, 서버가 리소스를 얻기 위해 게이트웨이 인터페이스 역할
게이트웨이 HTTP 트래픽을 다른 프로토콜로 자동변환 
HTTP 클라이언트가 다른 프로토콜 알 필요 없이 서버에 접속 할 수 있게 해줌 

> ex) FTP   
FTP URL을 가르키는 HTTP 요청을 받는다.   
게이트웨이는 FTP 커넥션 맺고 FTP 서버에 적절한 명령을 전송한다.   
클라이언트는 적절한 HTTP 헤더와 함께 HTTP를 통해 문서를 받는다.  
(카페24......ㅋㅋㅋㅋ)

> ex) HTTPS/HTTP     
게이트웨이는 암호화 된 웹 요청을 SSL 통해 받고, 요청 해독해서 생성한 일반 HTTP 요청을 목적지 서버로 전달   
보안 가속기는 원서버에 고성능 암호화 기능을 제공할 목적으로 웹서버의 바로 앞단에 위치시킬 수 있다. (우리가 자주 볼 수 있는 케이스)

### 클라이언트 측 게이트웨이 vs 서버측 게이트웨이 

웹 게이트웨이는 한쪽에서는 HTTP로 통신하고, 
다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다. 
게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다. 
ex) HTTPS/HTTP     

### 프로토콜 게이트웨이

게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.  
브라우저에 명시적으로 게이트웨이를 설정하여 저연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버로 설정할 수 있음.  


### HTTP/HTTPS: 서버측 보안 게이트웨이
웹 요청을 암호화 - 정보 보안 목적으로 게이트웨이 사용할 수 있음 
클라이언트는 일반 HTTP를 사용하여 웹 탐색. but, 게이트웨이는 _자동으로 사용자의 모든 세션을 암호화_

### HTTPS/HTTP: 클라이언트측 보안 가속 게이트웨이
HTTPS/HTTP 게이트웨이는 보안 가속기로 유명
웹 서버 앞단에 위치, 보이지 않는 _인터셉트 게이트웨이나 리버스 프락시 역할_ 을 한다! 
이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.   
이런 게이트웨이는 원 서보보다 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 한다. 
그러나 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기에 게이트웨이와 원 서버 간의 네트워크가 안전한지 확인을 하고 사용해야함....!

? 게이트웨이 == 리버스 프록시 ?

### 리소스 게이트웨이 
게이트 웨이의 일반적인 형태 : 목적지 서버와 게이트웨이를 한개의 서버로 _결합_
애플리케이션 서버는 서버 측 게이트웨이다.

### 터널
웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다. 
웹 터널로 HTTP 커넥션을 통해 HTTP가 아닌 트래픽 전송, 다른 프로토콜을 HTTP위에 올릴 수 있다.

### CONNECT 로 HTTP 터널 커넥션 맺기 
커넥션 메서드는 모든 서버나 프로토콜에 TCP 커넥션을 맺는데 사용할 수 있다. 
- connect 요청
  - 시작줄 제외하고 HTTP 메서드와 동일
  - 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술한다. 
  - web socket 연결할 때 이렇게 했었음.... 이게 터널을 만드는 것이었옹....
- connect 응답
  - HTTP와 동일하게 200 응답은 성공을 뜻함

### 데이터 터널링, 시간, 커넥션 관리
터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없다.게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할수 없다.  
성능을 높이기 위해.... 요청 후 응답 받기전에 터널 데이터를 전송 할 수 있음.


### SSL 터널링
암호화된 SSL 트래픽을 전달하려고 개발, 낡은 방식의 프락시는 SSL 처리 안되기 떄문에 터널을 사용하여 방화벽(프락시) 통과


### 릴레이
간한단 프락시를 구현하는 방식에 사용는데 
connection 헤더를 제대로 처리하지 못해서 Keep-alive 커넥션이 행에 걸려서 요청이 제대로 처리가 안되는 문제점이 있다. HTTP를 제대로 준수하는 프락시를 사용하는 것이 좋다. 
> 서버는 keep-alive를 요청받은 것이라고 생각해, 요청 처리가 끝나도 커넥션을 닫지 않는다. / 새로운 요청 릴레이가 처리하지 않아서 행에 걸린다.


