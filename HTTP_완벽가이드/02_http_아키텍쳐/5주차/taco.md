## Proxy란
프록시는 대리라는 뜻을 가진다.
그만큼 클라이언트와 서버 사이에서 중개를 하는 역할!
클라이언트의 편이 될수도 있고, 서버의 편이 될 수도 있고, 둘 다 아닐 수도 있다. 
여러 클라이언트 사이에서 공용 프락시로 역할을 할 수도 있고, 하나의 클라이언트만을 위할수도 있다. 
- 게이트웨이와의 차이점? 프락시는 같은 프로토콜 사이에서의 중개, 게이트웨이는 서로 다른 프로토콜 사이에서의 변환기처럼 작동.
- 그러나, 상용 프락시 서버는 게이트웨이 기능도 구현한다. 그리고 애초에 브라우저와 서버가 다른 버전의 HTTP 를 구현하여, 약간의 프로토콜 변환을 할 때가 있다.

## 프락시를 굳이 쓰는 이유?
1. 보안 개선 (보안 방화벽, 문서 접근 제어자, 어린이 필터, 익명화 프락시 등)
2. 성능 up (대리 프락시, 콘텐츠 라우터)
3. 비용 절약 (웹 캐시,콘텐츠 라우터)

## 프락시의 구조나 구성은
1. 출구 프락시 (로컬 네트워크에서, 더 큰 인터넷 사이에 위치해 보안, 성능적 개선을 꾀한다)
2. 접근 프락시 (모든 고객의 요청을 종합적으로 처리하기위함)
3. 대리 프락시 (서버 대신 역할을 해주는. 느린 웹 서버 앞에서 빠른 웹 서버 캐시 놓기)
4. 네트워크 교환 프락시 (네트워크와 네트워크 사이에 혼잡 완화를 위함)

이러한 프락시는 서로 계층도 있다. 콘텐츠 라우팅을 하게 되는데, 
정적으로도, 동적으로도 가능하다.
부하가 몰리거나 지리적인 특징, 특정한 URI를 갖고있으면 특별히 다른 곳으로 처리될 때도.
금액을 더 많이 냈다면 그들을 위한 라우터 기능으로서 작동.

이렇게 작동하는데, 클라이언트가 특별히 프락시로 가게끔 만드는 방법은?
1. 수동으로 작성해준다. (브라우저 내에서)
2. 스위칭 장치나 라우팅 장치를 통해서 인터셉트하는 방법
3. DNS 이름 수정(웹서버껄로)해서 대리 프락시로 이용
4. 웹 서버가 리다이렉트하게끔.

클라이언트로 하여금 자동으로 이래저래 프락시를 이용하게끔 PAC 파일을 사용할 수도 있다. 
브라우저에 알맞은 PAC 파일을 찾게끔 WPAD 프로토콜도 있다. (올바른 파일을 찾기위한 기법들이 있다.)

## 기억해두어야하는 특징들
프락시 URL의 경우 서버 URL과는 다르다. 
왜냐하면 불필요한 정보 발생을 피하려고 서버한테는 그간 부분 URL을 보냈기 때문이다. 
이미 많은 서버가 배치됐기 때문에, 그냥 명시적 프록시가 있을 경우는 완전한 URL, 없을 경우는 부분 URL을 보내게 된다. 

그런데, 이는 다른 문제를 불렀는데, 대리 프락시나 인터셉트 프락시와 같은 것들이 있었기 때문이다.
클라이언트는 대리나 인터셉트 프록시를 잘 모르기 때문.
이를 해결할 방법은 가상 호스트의 HOST 헤더를 이용하거나, 없다면 에러메세지를 보낸다. 

브라우저는 프록시 존재 여부에 따라 요청 URI를 다르게 분석한다. 
- 프락시 없는 URI 분석 (브라우저가 자동 확장 이용)
- 명시적 프락시를 사용할 때 URI 분석 (자동 확장하지 않는다.)
- 인터셉트 프락시를 이용한 분석 (인터셉트했기 때문에, 서버로의 커넥션이 없어도 없는지도 모른다.)
모두 다르다. 

## 여러 프록시를 대처하는 Via, TRACE 메서드
- Via 헤더를 통해서 우리는 어떤 프로토콜 이름, 버전, 노드 이름 등을 알 수 있고, 게이트웨이 기능을 사용했는지 아닌지 등을 파악 가능하다. 만약 정확한 호스트명을 Via 내에 포함시키고 싶지 않다면, 적당한 가명으로 교체해야한다. 
- 여러 프록시를 사용하게 되면서, 우리는 홉에서 홉으로 전달될 때마다 메세지의 내용이 어떻게 변하는지 편리하게 관찰할 방법이 필요하다. 이는 HTTP/1.1의 TRACE 메서드로 가능 (Max-Forwards 사용)

## 상호운용성을 위한 노력
- 지원하지 않는 헤더나 메서드를 다룰 때, 상대적 순서 모두 유지한 채 가능한 한 그 메세지를 다음 홉으로 전달해야한다. 
- OPTIONS를 통해 기능 확인 (특정 리소스 혹은 전체 리소스 확인 가능)
- Allow 헤더
